@model dynamic
@using Newtonsoft.Json
@{
    ViewData["Title"] = "Dashboard Arca Planta Insurgentes";
}
@inject Microsoft.Extensions.Localization.IStringLocalizer Localizer

<h4>@Localizer["XR_Title"]</h4>




<form id="selectionForm" target="_blank">
    <div class="row row-cols-lg-auto g-2 align-items-end">
        <!-- Fechas -->
        <div class="col">
            <label for="startDate" class="form-label">@Localizer["XR_From"]</label>
        </div>
        <div class="col">
            <input type="datetime-local" id="startDate" name="startDate" class="form-control form-control-sm" />
        </div>
        <div class="col">
            <label for="endDate" class="form-label">@Localizer["XR_To"]</label>
        </div>
        <div class="col">
            <input type="datetime-local" id="endDate" name="endDate" class="form-control form-control-sm" />
        </div>

        <!-- País / Planta -->
        <div class="col">
            <label for="pais" class="form-label">@Localizer["XR_Country"]</label>
        </div>
        <div class="col">
            <select id="pais" class="form-select form-select-sm">
                <option value="">-- Selecciona --</option>
                @foreach (var p in ViewBag.Countries)
                {
                    <option value="@p.Code">@p.Name</option>
                }
            </select>
        </div>
        <div class="col">
            <label for="planta" class="form-label">@Localizer["XR_Plant"]</label>
        </div>
        <div class="col">
            <select id="planta" name="planta" class="form-select form-select-sm">
                <option value="">-- Selecciona --</option>
            </select>
        </div>

        <!-- Línea -->
        <div class="col">
            <label for="line" class="form-label">@Localizer["XR_Line"]</label>
        </div>
        <div class="col">
            <select id="line" name="line" class="form-select form-select-sm"></select>
        </div>

        <!-- SKU -->
        <div class="col">
            
            <label for="sku" class="form-label">@Localizer["XR_SKU"]</label>
        </div>
        <div class="col">
            <select id="sku" name="sku" class="form-select form-select-sm">
                <option value="">SKU</option>
            </select>
        </div>

        <!-- Variables -->
        <div class="col">
            
            <label for="variableYSelect" class="form-label">@Localizer["XR_VarY"]</label>
        </div>
        <div class="col">
            <select id="variableYSelect" name="variableYSelect" class="form-select form-select-sm">
                <option value="">Selecciona Variable Y</option>
            </select>
        </div>
        <div class="col">
            <label for="variablesX" class="form-label">@Localizer["XR_VarX"]</label>
        </div>
        <div class="col">
            <select id="variablesX" name="variablesX" class="form-select form-select-sm">
                <option value="">Selecciona Variable X</option>
            </select>
        </div>
        <div class="col">
            <button id="btnReporte" type="button" class="btn btn-primary btn-sm" onclick="runReportXR()">
                📊 @Localizer["XR_ReportBtn"]
            </button>
            

        </div>
    </div>

    <input type="hidden" id="variableY" name="variableY" />
</form>
<div class="mt-3">

    <!-- Tabs -->
    <ul class="nav nav-tabs" id="xrTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="tab-resumen"
                    data-bs-toggle="tab" data-bs-target="#pane-resumen"
                    type="button" role="tab" aria-controls="pane-resumen" aria-selected="true">
                @Localizer["XR_Tab_Summary"]  <!-- Resumen -->
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="tab-analisis"
                    data-bs-toggle="tab" data-bs-target="#pane-analisis"
                    type="button" role="tab" aria-controls="pane-analisis" aria-selected="false">
                @Localizer["XR_Tab_Analysis"]  <!-- Más análisis -->
            </button>
        </li>
    </ul>

    <div class="tab-content" id="xrTabsContent">

        <!-- =======================
             PESTAÑA 1: RESUMEN
             (Time series + Histograma + Cpk interactivo)
             ======================= -->
        <div class="tab-pane fade show active" id="pane-resumen" role="tabpanel" aria-labelledby="tab-resumen">
            <div class="row g-3 pt-3">

                <!-- 1) Time series (ids existentes) -->
                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_TimeSeries"]</h6>
                            <div id="chartXR" style="height:340px;"></div>
                        </div>
                    </div>
                </div>

                <!-- 2) Histograma (ids existentes) -->
                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_Hist"]</h6>
                            <div id="histXR" style="height:340px;"></div>
                        </div>
                    </div>
                </div>

                <!-- 2.1) Capability breve (tabla compacta) -->
                <div class="col-12">
                    <div class="card">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_Capability"]</h6>
                            <div id="capTableXR"></div> <!-- ya existente -->
                        </div>
                    </div>
                </div>

                <!-- 3) Cpk interactivo con filtro de outliers -->
                <div class="col-12">
                    <div class="card">
                        <div class="card-body">

                            <div class="d-flex flex-wrap align-items-end gap-2 mb-2" id="cpkControls">
                                <div>
                                    <label class="form-label mb-1" for="cpkMethod">@Localizer["XR_OutlierMethod"]</label>
                                    <select id="cpkMethod" class="form-select form-select-sm" style="min-width:180px">
                                        <option value="none">@Localizer["XR_OM_None"]</option>
                                        <option value="z">Z-score</option>
                                        <option value="iqr">IQR (Tukey)</option>
                                    </select>
                                </div>

                                <div id="cpkZWrap" style="display:none">
                                    <label class="form-label mb-1" for="cpkZ">@Localizer["XR_ZThreshold"]</label>
                                    <input id="cpkZ" type="number" step="0.1" class="form-control form-control-sm" value="3" style="width:100px" />
                                </div>

                                <div id="cpkIqrWrap" style="display:none">
                                    <label class="form-label mb-1" for="cpkIqrK">@Localizer["XR_IQRk"]</label>
                                    <input id="cpkIqrK" type="number" step="0.1" class="form-control form-control-sm" value="1.5" style="width:100px" />
                                </div>

                                <div id="sigmaLegend" style="display:flex; gap:12px; flex-wrap:wrap; margin:8px 0;">
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <span style="display:inline-block;width:16px;height:16px;background:#34c759;border:1px solid #333"></span>
                                        <span>±1σ</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <span style="display:inline-block;width:16px;height:16px;background:#ffcc00;border:1px solid #333"></span>
                                        <span>±2σ</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:4px;">
                                        <span style="display:inline-block;width:16px;height:16px;background:#ff3b30;border:1px solid #333"></span>
                                        <span>±3σ</span>
                                    </div>
                                </div>

                                <div class="ms-auto d-flex gap-2">
                                    <button id="cpkRun" type="button" class="btn btn-primary btn-sm">
                                        @Localizer["XR_CalcAndPlot"]   <!-- Calcular y graficar -->
                                    </button>
                                    <!--
                                    <button id="cpkToggleRemoved" type="button" class="btn btn-secondary btn-sm">
                                        @Localizer["XR_ShowFiltered"]  <!-- Mostrar puntos filtrados 
                                    </button>
                                    -->
                                </div>
                                <div class="ms-2 d-flex align-items-center gap-2">
                                    <span id="cpkManualBadge" class="badge bg-warning text-dark">Excluidos: 0</span>
                                    <button id="cpkResetManual" type="button" class="btn btn-outline-secondary btn-sm">Reset manual</button>
                                    <button id="cpkResetZoom" type="button" class="btn btn-outline-secondary btn-sm">Reset zoom</button>
                                </div>

                            </div>

                            <!-- Gráfica Cpk interactivo -->
                            <div id="cpkChart" style="height:360px;"></div>

                            <!-- KPIs Cpk -->
                            <div id="cpkKpis" class="row row-cols-2 row-cols-md-6 g-2 mt-2">
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_nTotal"]</div><div id="cpk_nTotal">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_nUsed"]</div><div id="cpk_nUsed">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_Mean"]</div><div id="cpk_mean">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_Std"]</div><div id="cpk_std">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_Cp"]</div><div id="cpk_cp">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center small">
                                        <div class="text-muted">@Localizer["XR_KPI_Cpk"]</div><div id="cpk_cpk">—</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Cpk bruto vs filtrado (cards compactas) -->
                            <div class="row row-cols-1 row-cols-md-2 g-2 mt-2">
                                <div class="col">
                                    <div class="border rounded p-2 text-center">
                                        <div class="text-muted small">@Localizer["XR_CpkRaw"]</div>
                                        <div id="cpk_raw" class="fs-5">—</div>
                                    </div>
                                </div>
                                <div class="col">
                                    <div class="border rounded p-2 text-center">
                                        <div class="text-muted small">@Localizer["XR_CpkFiltered"]</div>
                                        <div id="cpk_filtered" class="fs-5">—</div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- =======================
             PESTAÑA 2: MÁS ANÁLISIS
             (Xbar/R, Run, Normal Prob, Capability Plot)
             ======================= -->
        <div class="tab-pane fade" id="pane-analisis" role="tabpanel" aria-labelledby="tab-analisis">
            <div class="row g-3 pt-3">

                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_XbarTitle"]</h6>
                            <div id="xbarXR" style="height:260px;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_RTitle"]</h6>
                            <div id="rchartXR" style="height:260px;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_RunTitle"]</h6>
                            <div id="runXR" style="height:260px;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-12 col-lg-6">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_NormProbTitle"]</h6>
                            <div id="normprobXR" style="height:280px;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-12">
                    <div class="card h-100">
                        <div class="card-body">
                            <h6 class="text-muted">@Localizer["XR_CapPlotTitle"]</h6>
                            <div id="capPlotXR" style="height:260px;"></div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </div>
</div>



@section Scripts {
    
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

    <!-- Exponer textos localizados para usarlos en JS -->
    <script>
        const L = {
            Title: "@Localizer["XR_Title"]",
            From: "@Localizer["XR_From"]",
            To: "@Localizer["XR_To"]",
            Country: "@Localizer["XR_Country"]",
            Plant: "@Localizer["XR_Plant"]",
            Line: "@Localizer["XR_Line"]",
            SKU: "@Localizer["XR_SKU"]",
            VarY: "@Localizer["XR_VarY"]",
            VarX: "@Localizer["XR_VarX"]",
            SelectVarY: "@Localizer["XR_SelectVarY"]",
            SelectVarX: "@Localizer["XR_SelectVarX"]",
            ReportBtn: "@Localizer["XR_ReportBtn"]",
            TimeSeries: "@Localizer["XR_TimeSeries"]",
            Hist: "@Localizer["XR_Hist"]",
            Capability: "@Localizer["XR_Capability"]",
            XbarTitle: "@Localizer["XR_XbarTitle"]",
            RTitle: "@Localizer["XR_RTitle"]",
            RunTitle: "@Localizer["XR_RunTitle"]",
            NormProbTitle: "@Localizer["XR_NormProbTitle"]",
            CapPlotTitle: "@Localizer["XR_CapPlotTitle"]",
            SelectFilters: "@Localizer["XR_SelectFilters"]",
            NoData: "@Localizer["XR_NoData"]",
            LoadSkuErr: "@Localizer["XR_LoadSkuErr"]",
            NoCapData: "@Localizer["XR_NoCapData"]",
            tbl_Variable: "@Localizer["XR_tbl_Variable"]",
            tbl_n: "@Localizer["XR_tbl_n"]",
            tbl_Subgroups: "@Localizer["XR_tbl_Subgroups"]",
            tbl_Mean: "@Localizer["XR_tbl_Mean"]",
            tbl_SigmaOverall: "@Localizer["XR_tbl_SigmaOverall"]",
            tbl_SigmaWithin: "@Localizer["XR_tbl_SigmaWithin"]",
            tbl_LSL: "@Localizer["XR_tbl_LSL"]",
            tbl_USL: "@Localizer["XR_tbl_USL"]",
            tbl_Cp: "@Localizer["XR_tbl_Cp"]",
            tbl_Cpk: "@Localizer["XR_tbl_Cpk"]",
            tbl_Pp: "@Localizer["XR_tbl_Pp"]",
            tbl_Ppk: "@Localizer["XR_tbl_Ppk"]",
            Result: "@Localizer["XR_Result"]",
            LSL: "@Localizer["XR_LSL"]",
            USL: "@Localizer["XR_USL"]",
            Subgroup: "@Localizer["XR_Subgroup"]",
            Data: "@Localizer["XR_Data"]",
            Fit: "@Localizer["XR_Fit"]",
            WithinBand: "@Localizer["XR_WithinBand"]",
            OverallBand: "@Localizer["XR_OverallBand"]"
        };
    </script>

    <script>
        // =======================
        // Catálogo País / Planta (puedes internacionalizarlo si quieres)
        // =======================
        const catalogo = {
            "México": ["Favorita", "Guadalupe", "Chihuahua", "Mexicali", "Insurgentes", "San Agustín",
                "Ciudad Juárez", "Culiacán", "Piedras Negras", "Hermosillo", "Aguascalientes",
                "Topo Chico", "San Luis Potosí", "Durango", "La Paz", "Zapopan", "Matamoros",
                "Trojes", "Nogales", "Saltillo"],
            "Perú": ["Zárate", "Pucusana", "Trujillo", "Arequipa", "Iquitos", "Cusco"],
            "USA": ["Fossil Creek", "North Point", "Oklahoma", "San Antonio", "Abilene", "El Paso", "McAllen"],
            "Ecuador": ["Guayaquil", "Quito", "Santo Domingo", "Tony - Lacteos", "Lacteos - solo dat"],
            "Argentina": ["Salta", "Tucumán", "Formosa"]
        };

        const MODULO_PERMISOS = "DQxr";

        const LABELS = {
            Select: "-- Selecciona --",
            Line: "@Localizer["XR_Line"]",
            Plant: "@Localizer["XR_Plant"]"
        };

        // Todas las companies (Company, CompanyName, CountryCode) desde backend
        const COMPANIES = @Html.Raw(ViewBag.CompaniesJson ?? "[]");
        console.log("companies", COMPANIES);

        function toArray(data) {
            if (!data) return [];
            if (Array.isArray(data)) return data;
            if (Array.isArray(data.$values)) return data.$values;
            if (Array.isArray(data.value?.$values)) return data.value.$values;
            if (Array.isArray(data.value)) return data.value;
            return [];
        }

        function resetSelect($el, placeholder) {
            $el.empty().append(new Option(placeholder, ""));
        }

        // Helpers de permisos
        function getPermisoModulo() {
            if (!window.PERMISOS_POR_MODULO) return null;
            return window.PERMISOS_POR_MODULO[MODULO_PERMISOS] || null;
        }

        function getUserCompanyInfo() {
            if (!window.USER_COMPANY || !Array.isArray(COMPANIES)) return null;
            return COMPANIES.find(c => c.Company === window.USER_COMPANY) || null;
        }

        // 1) País → cargar Plantas
        // País → cargar Plantas
        function fillPlants(countryCode) {
            const $planta = $("#planta");
            resetSelect($planta, LABELS.Plant);
            resetSelect($("#line"), LABELS.Line); // limpiar línea

            if (!countryCode) return;

            const permiso = getPermisoModulo();
            const userInfo = getUserCompanyInfo();
            const userCompany = userInfo ? userInfo.Company : null;

            let plants = COMPANIES
                .filter(c => c.CountryCode === countryCode)
                .sort((a, b) => a.CompanyName.localeCompare(b.CompanyName, 'es'));

            // SOLO si fuera nivel planta puro (Global=false, Country=false, Planta=true)
            // limitaríamos a una planta. En DQanasens tienes Country=true, así que ve todas las plantas de México.
            if (permiso && !permiso.Global && !permiso.Country && permiso.Planta && userCompany) {
                plants = plants.filter(p => p.Company === userCompany);
            }

            plants.forEach(p => $planta.append(new Option(p.CompanyName, p.Company)));

            // Si tiene permiso de planta, auto-seleccionar su planta
            // Si el permiso es SOLO de planta (sin Global ni Country) → auto-seleccionar y bloquear
            if (permiso && permiso.Planta && userCompany && !permiso.Global && !permiso.Country) {
                $planta.val(userCompany);
                $planta.prop("disabled", true);
            } else {
                // En cualquier otro caso: no forzar selección, dejarlo editable
                $planta.prop("disabled", false);
            }

        }


        // Eventos
        $("#pais").on("change", function () {
            fillPlants(this.value);
        });

        $(function () {
            const $pais = $("#pais");
            const permiso = getPermisoModulo();
            const userInfo = getUserCompanyInfo();
            const userCountry = userInfo ? userInfo.CountryCode : null;

            if (!$pais[0]) return;

            // Si tiene Global → puede ver todos los países
            if (permiso && permiso.Global) {
                if (userCountry) {
                    $pais.val(userCountry);
                } else if ($pais[0].options.length > 1) {
                    $pais[0].selectedIndex = 1;
                }
                $pais.prop("disabled", false);
            }
            // Si NO Global pero sí Country/Planta → solo su país, bloqueado
            else if (permiso && (permiso.Country || permiso.Planta) && userCountry) {
                $pais.find("option").each(function () {
                    const val = this.value;
                    if (val && val !== userCountry) {
                        $(this).remove();
                    }
                });
                $pais.val(userCountry);
                $pais.prop("disabled", true);
            }
            // Fallback (sin permisos, por si acaso)
            else {
                if ($pais[0].options.length > 1) {
                    $pais[0].selectedIndex = 1;
                }
                $pais.prop("disabled", false);
            }

            // Disparar carga de plantas con el país seleccionado
            const selectedCountry = $pais.val();
            if (selectedCountry) {
                fillPlants(selectedCountry);
            }
        });
        // Forzar habilitado inicial (si no usas gating por selects)
        $(document).ready(function () {
            $('#btnReporte').prop('disabled', false);
        });

        // Habilitar/deshabilitar botón según selecciones (opcional)
        function updateReportButtons() {
            const hasY = !!$("#variableYSelect").val();
            const hasX = !!$("#variablesX").val();
            $("#btnReporte").prop("disabled", !(hasY && hasX));
        }
        $('#variableYSelect, #variablesX, #line, #sku, #startDate, #endDate')
            .on('change input', updateReportButtons);
/*
        // País / Planta
        function llenarPaises() {
            const $p = $("#pais");
            $p.empty();
            Object.keys(catalogo).forEach(pais => $p.append(new Option(pais, pais)));
            $p.val(DEFAULT_PAIS);
        }
        function llenarPlantas(pais) {
            const $pl = $("#planta");
            const plantas = catalogo[pais] || [];
            $pl.empty();
            plantas.forEach(pl => $pl.append(new Option(pl, pl)));
            if (pais === DEFAULT_PAIS && plantas.includes(DEFAULT_PLANTA)) $pl.val(DEFAULT_PLANTA);
            else if (plantas.length) $pl.val(plantas[0]);
        }
        $("#pais").on("change", function () {
            llenarPlantas(this.value);
            $("#sku").empty().append(`<option value="">${L.SKU}</option>`);
            resetYAndX();
        }); */
         
        $("#planta").on("change", function () {
            $("#sku").empty().append(`<option value="">${L.SKU}</option>`);
            resetYAndX();
        });


        // =======================
        // Helper: normalizar arrays (para $values)
        // =======================
        function toArray(data) {
            if (!data) return [];
            if (Array.isArray(data)) return data;
            if (Array.isArray(data.$values)) return data.$values;
            if (Array.isArray(data.value?.$values)) return data.value.$values;
            if (Array.isArray(data.value)) return data.value;
            return [];
        }

        // --- Detección de Run Rules (Western/Nelson equivalentes) sobre los PUNTOS USADOS ---
        function detectRunRules(values, keepMask, mean, sd) {
            const res = { r1: new Set(), r2: new Set(), r3: new Set(), r4: new Set(), r5: new Set() };
            if (!Number.isFinite(mean) || !Number.isFinite(sd) || sd <= 0) return res;

            const UCL = mean + 3 * sd, LCL = mean - 3 * sd;

            // Lista de puntos incluidos (en orden), con z y lado
            const inc = values
                .map((v, i) => ({ i, v, keep: !!keepMask[i] }))
                .filter(p => p.keep)
                .map(p => ({ ...p, z: (p.v - mean) / sd, side: (p.v >= mean ? 1 : -1) }));

            // Regla #1: ≥1 punto más allá de ±3σ (fuera de control)
            inc.forEach(p => { if (p.v > UCL || p.v < LCL) res.r1.add(p.i); });

            // Regla #2: 2 de 3 en Zona A o más allá (|z| ≥ 2) — ventana de 3
            for (let k = 0; k <= inc.length - 3; k++) {
                const win = inc.slice(k, k + 3);
                const hi = win.filter(p => Math.abs(p.z) >= 2);
                // al menos dos y que compartan signo
                if (hi.length >= 2 && (hi[0].side === hi[1].side || (hi[2] && hi[0].side === hi[2].side) || (hi[2] && hi[1].side === hi[2].side))) {
                    hi.forEach(p => res.r2.add(p.i));
                }
            }

            // Regla #3: 4 de 5 en Zona B (|z| >= 1) y del MISMO lado — ventana de 5
            for (let k = 0; k <= inc.length - 5; k++) {
                const win = inc.slice(k, k + 5);
                const hi = win.filter(p => Math.abs(p.z) >= 1);
                if (hi.length >= 4) {
                    // ¿hay al menos 4 con el mismo side?
                    const pos = hi.filter(p => p.side === 1).length;
                    const neg = hi.length - pos;
                    if (pos >= 4 || neg >= 4) hi.forEach(p => res.r3.add(p.i));
                }
            }

            // Regla #4: 8 o más del mismo lado de la media (sin cruzar)
            let runStart = 0;
            for (let k = 1; k <= inc.length; k++) {
                if (k === inc.length || inc[k].side !== inc[k - 1].side) {
                    const len = k - runStart;
                    if (len >= 8) for (let j = runStart; j < k; j++) res.r4.add(inc[j].i);
                    runStart = k;
                }
            }

            // Regla #5: 6 o más seguidos en tendencia (estrictamente ↑ o ↓)
            let incRun = 1, decRun = 1;
            for (let k = 1; k < inc.length; k++) {
                if (inc[k].v > inc[k - 1].v) { incRun++; decRun = 1; }
                else if (inc[k].v < inc[k - 1].v) { decRun++; incRun = 1; }
                else { /* iguales: no rompas ambas, permite continuidad suave */ incRun++; decRun++; }

                if (incRun >= 6) for (let j = k - incRun + 1; j <= k; j++) res.r5.add(inc[j].i);
                if (decRun >= 6) for (let j = k - decRun + 1; j <= k; j++) res.r5.add(inc[j].i);
            }

            return res;
        }

        // Sustituye tu cpkZonesMarkArea por ESTA versión
        // Reemplaza COMPLETO cpkZonesMarkArea(...) por esto
        function cpkZonesMarkArea(mu, sd) {
            if (!Number.isFinite(mu) || !Number.isFinite(sd) || sd <= 0) return null;

            const z1 = mu - sd, z2 = mu - 2 * sd, z3 = mu - 3 * sd;
            const p1 = mu + sd, p2 = mu + 2 * sd, p3 = mu + 3 * sd;

            // Colores vivos con más opacidad
            const C3 = 'rgba(255, 59, 48, 0.35)';   // ±3σ rojo
            const C2 = 'rgba(255, 204, 0, 0.30)';   // ±2σ amarillo
            const C1 = 'rgba(52, 199, 89, 0.28)';   // ±1σ verde

            // Helper para crear un "área" con etiqueta centrada
            const area = (y0, y1, color, label) => ({
                type: 'line',
                silent: true,
                // name no aparece en la leyenda (solo para depurar); las etiquetas van en markArea.label
                markArea: {
                    silent: true,
                    itemStyle: { color },
                    label: {
                        show: false,
                        position: 'inside',
                        color: '#111',
                        fontWeight: 'bold',
                        formatter: label
                    },
                    data: [[{ yAxis: y0 }, { yAxis: y1 }]]
                }
            });

            return [
                // ±3σ: (−3σ, −2σ) y (2σ, 3σ)
                area(z3, z2, C3, '−3σ ⇢ −2σ'),
                area(p2, p3, C3, '2σ ⇢ 3σ'),

                // ±2σ: (−2σ, −1σ) y (1σ, 2σ)
                area(z2, z1, C2, '−2σ ⇢ −1σ'),
                area(p1, p2, C2, '1σ ⇢ 2σ'),

                // ±1σ: (−1σ, μ) y (μ, 1σ)
                area(z1, mu, C1, '−1σ ⇢ μ'),
                area(mu, p1, C1, 'μ ⇢ 1σ')
            ];
        }




        // =======================
        // Estado
        // =======================
        function resetYAndX() {
            $("#variableYSelect").empty().append(`<option value="">${L.SelectVarY}</option>`);
            $("#variablesX").empty().append(`<option value="">${L.SelectVarX}</option>`);
            updateReportButtons();
        }

        // =======================
        // AJAX: SKU
        // =======================
        function cargarProductos() {
            var lineaId = $("#line").val();
            var fechaInicial = $("#startDate").val();
            var fechaFinal = $("#endDate").val();
            var planta = $("#planta").val();
            if (lineaId && fechaInicial && fechaFinal) {
                $.ajax({
                    url: '@Url.Action("ObtenerProductos_XR", "XRcharts")',
                    type: 'GET',
                    data: { lineaId, fechaInicial, fechaFinal, planta },
                    success: function (data) {
                        const productos = toArray(data);
                        const $dd = $("#sku");
                        $dd.empty().append(`<option value="">${L.SKU}</option>`);
                        productos.forEach(p => {
                            $dd.append(`<option value="${p.manufacturingOrder}">${p.manufacturingReferenceName}</option>`);
                        });
                    },
                    error: function () { alert(L.LoadSkuErr); }
                });
            } else {
                $("#sku").empty().append(`<option value="">${L.SKU}</option>`);
            }
        }
        $("#line, #startDate, #endDate").on("change", cargarProductos);

        // =======================
        // AJAX: Variables Y
        // =======================
        $("#sku").on("change", function () { cargarVarY(); });

        function cargarVarY() {
            const sku = $("#sku").val();
            const fechaInicial = $("#startDate").val();
            const fechaFinal = $("#endDate").val();
            const lineaId = $("#line").val();
            const planta = $("#planta").val();
            if (!sku) { resetYAndX(); return; }

            $.ajax({
                url: '@Url.Action("ObtenerVarY_XR", "XRcharts")',
                type: 'GET',
                data: { sku, startDate: fechaInicial, endDate: fechaFinal, line: lineaId, planta: planta },
                success: function (data) {
                    const itemsRaw = toArray(data);
                    const $y = $("#variableYSelect");
                    $y.empty().append(`<option value="">${L.SelectVarY}</option>`);
                    itemsRaw.forEach(it => $y.append(new Option(it.name, it.value)));
                    $y.off("change").on("change", function () {
                        $("#variableY").val(this.value);
                        cargarVarX();
                    });
                }
            });
        }

        // =======================
        // AJAX: Variables X
        // =======================
        function cargarVarX() {
            const sku = $("#sku").val();
            const varYCode = $("#variableYSelect").val();
            const fechaInicial = $("#startDate").val();
            const fechaFinal = $("#endDate").val();
            const lineaId = $("#line").val();
            const planta = $("#planta").val();
            if (!(sku && varYCode)) return;

            $.ajax({
                url: '@Url.Action("ObtenerVarX_XR", "XRcharts")',
                type: 'GET',
                data: { sku, varY: varYCode, fechaInicial, fechaFinal, lineaId, planta },
                success: function (data) {
                    const list = toArray(data);
                    const $x = $("#variablesX");
                    $x.empty().append(`<option value="">${L.SelectVarX}</option>`);
                    list.forEach(v => $x.append(new Option(v.name, v.value)));
                    if (list.length) { $x.val(list[0].value); }
                    updateReportButtons();
                },
                error: function (xhr) { console.error("ObtenerVarX_XR error", xhr); }
            });
        }

        // =======================
        // RUN REPORT (fetch + draw)
        // =======================
        async function runReportXR() {
            const from = $("#startDate").val();
            const to = $("#endDate").val();
            const workplace = $("#line").val();
            const planta = $("#planta").val();
            const reference = $("#sku").val();
            const controlOp = $("#variablesX").val() || $("#variableYSelect").val();
            if (!(from && to && workplace && controlOp)) { alert(L.SelectFilters); return; }

            try {
                // 1) Base rows
                const baseUrl = '@Url.Action("GetBaseRows", "XRcharts")';
                const params = { 
                    from, 
                    to, 
                    workplace, 
                    reference: null, 
                    controlOperation: controlOp, 
                    planta 
                };

                console.log("➡️ Parámetros enviados a GetBaseRows:", params);

                const query = $.param(params);
                console.log("➡️ URL final:", baseUrl + "?" + query);

                const baseResp = await $.getJSON(baseUrl, params);

                console.log("📥 BaseRows (raw):", baseResp);  // <--- aquí imprimes todo el JSON crudo

                const rows = Array.isArray(baseResp) ? baseResp :
                    Array.isArray(baseResp?.$values) ? baseResp.$values : baseResp;

                const items = rows.map(r => ({
                    ts: new Date(r.executionDate),
                    y: Number(r.resultValue),
                    lsl: r.LSL != null ? Number(r.LSL) : null,
                    usl: r.USL != null ? Number(r.USL) : null,
                    target: r.Target != null ? Number(r.Target) : null,
                    specType: r.specType || 'No-spec',     // 'Two-sided' | 'LSL-only' | 'USL-only' | 'No-spec'
                    sg: r.subgroupId,
                    n: Number(r.subgroupN) || null,        // tamaño de subgrupo
                    name: r.controlOperationName
                })).filter(p => Number.isFinite(p.y) && p.ts);

                if (!items.length) { alert(L.NoData); return; }

                // 2) Capability
                const capUrl = '@Url.Action("GetCapability", "XRcharts")';
                const capResp = await $.getJSON(capUrl, { from, to, workplace, reference: null, controlOperation: controlOp, planta });
                console.log("📥 Capability (raw):", capResp);  // <--- aquí también
                
                const capRows = Array.isArray(capResp) ? capResp :
                    Array.isArray(capResp?.$values) ? capResp.$values : capResp;
                const cap = capRows && capRows.length ? capRows[0] : null;

                // Subgrupos (Xbar y R)
                const bySg = {};
                for (const it of items) {
                    if (!bySg[it.sg]) bySg[it.sg] = [];
                    bySg[it.sg].push(it);
                }
                console.log(items);
                const sgKeys = Object.keys(bySg).sort((a, b) => bySg[a][0].ts - bySg[b][0].ts);

                // construir arrays de medias y rangos
                const xbarData = [];
                const rData = [];
                const nList = [];
                sgKeys.forEach((k, i) => {
                    const vals = bySg[k].map(o => o.y);
                    const t0 = bySg[k][0].ts;
                    xbarData.push({ idx: i + 1, ts: t0, mean: avg(vals) });
                    rData.push({ idx: i + 1, ts: t0, r: Math.max(...vals) - Math.min(...vals) });
                    nList.push(bySg[k][0].n || vals.length);
                });

                const LSL = items.find(p => p.lsl != null)?.lsl ?? null;
                const USL = items.find(p => p.usl != null)?.usl ?? null;
                const Target = items.find(p => p.target != null)?.target
                    ?? ((LSL != null && USL != null) ? (LSL + USL) / 2 : null);
                const specType = items.find(p => !!p.specType)?.specType || 'No-spec';
                const spec = { LSL, USL, Target, specType };

                // ===== Límites de control Xbar–R (con tu lógica actual) =====
                const nSub = bySg[sgKeys[0]]?.length ?? 0;
                const C = XR_CONST[nSub] || XR_CONST[5]; // fallback n=5 si no hay
                const groups = sgKeys.map(k => bySg[k].map(o => o.y));

                const XBARBAR = xbarbar(groups);
                const RBAR = rbar(groups);

                const ctrlX = { UCL: XBARBAR + C.A2 * RBAR, CL: XBARBAR, LCL: XBARBAR - C.A2 * RBAR };
                const ctrlR = { UCL: C.D4 * RBAR, CL: RBAR, LCL: C.D3 * RBAR };

                // ===== Dibujar (ahora pasamos spec) =====
                renderXRTime(items, spec);
                renderXRHistogram(items, spec);
                renderXRCapTable(cap);

                initCpkModule();              // asegura que los controles estén listos (una sola vez)
                renderCpkInteractive(items, spec);

                // Xbar y R con límites de control + líneas de especificación
                renderXbarChart(xbarData, ctrlX, spec);
                renderRChart(rData, ctrlR);

                // (estos pueden quedarse igual, o pasar spec si luego quieres Target también)
                renderRunChart(items, LSL, USL);
                renderNormalProb(items, LSL, USL);
                renderCapabilityPlot(cap, LSL, USL);

                window._xr_last = { items, spec, xbarData, rData, ctrlX, ctrlR, LSL, USL, cap };

            } catch (err) {
                console.error(err);
                alert("Error"); // texto técnico; si quieres lo etiquetamos también
            }
        }
        window.runReportXR = runReportXR;

        // =======================
        // Renderers (con etiquetas)
        // =======================
        function renderXRTime(points, spec) {
            const dom = document.getElementById('chartXR');
            const chart = echarts.init(dom);

            const lsl = spec?.LSL ?? points.find(p => p.lsl != null)?.lsl ?? null;
            const usl = spec?.USL ?? points.find(p => p.usl != null)?.usl ?? null;
            const tgt = spec?.Target ?? points.find(p => p.target != null)?.target ?? null;

            chart.setOption({
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'time' },
                yAxis: { type: 'value', scale: true },
                legend: { top: 0 },
                series: [
                    { type: 'line', name: L.Result, showSymbol: false, data: points.map(p => [p.ts, p.y]), areaStyle: { opacity: 0.08 } },
                    ...(lsl != null ? [{ type: 'line', name: `${L.LSL}`, symbol: 'none', lineStyle: { type: 'dashed' }, data: points.map(p => [p.ts, lsl]) }] : []),
                    ...(tgt != null ? [{ type: 'line', name: '@Localizer["XR_Target"]', symbol: 'none', lineStyle: { type: 'dotted' }, data: points.map(p => [p.ts, tgt]) }] : []),
                    ...(usl != null ? [{ type: 'line', name: `${L.USL}`, symbol: 'none', lineStyle: { type: 'dashed' }, data: points.map(p => [p.ts, usl]) }] : [])
                ]
            });
        }

        function renderXRHistogram(points, spec) {
            const dom = document.getElementById('histXR');
            const chart = echarts.init(dom);

            const vals = points.map(p => p.y).filter(Number.isFinite);
            if (!vals.length) { chart.clear(); return; }

            const sorted = vals.slice().sort((a, b) => a - b);
            const min = sorted[0], max = sorted[sorted.length - 1];
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const iqr = (q3 - q1) || (max - min) || 1;
            const binW = Math.max(iqr * Math.pow(vals.length, -1 / 3), 1e-9);
            const bins = Math.max(5, Math.min(40, Math.ceil((max - min) / binW)));
            const edges = Array.from({ length: bins + 1 }, (_, i) => min + i * (max - min) / bins);
            const counts = new Array(bins).fill(0);
            vals.forEach(v => {
                let idx = Math.min(bins - 1, Math.max(0, Math.floor((v - min) / (max - min) * bins)));
                counts[idx]++;
            });
            const centers = edges.slice(0, -1).map((e, i) => (e + edges[i + 1]) / 2);

            const mu = avg(vals);
            const sd = Math.sqrt(avg(vals.map(v => (v - mu) * (v - mu))));
            const densityX = Array.from({ length: 120 }, (_, i) => min + (i / 119) * (max - min));
            const norm = x => (1 / (sd * Math.sqrt(2 * Math.PI))) * Math.exp(-(x - mu) * (x - mu) / (2 * sd * sd));
            const maxCnt = Math.max(...counts);
            const scale = maxCnt / Math.max(...densityX.map(norm)); // escala densidad al histo
            const densityY = densityX.map(x => norm(x) * scale);

            const lsl = spec?.LSL ?? points.find(p => p.lsl != null)?.lsl ?? null;
            const usl = spec?.USL ?? points.find(p => p.usl != null)?.usl ?? null;
            const tgt = spec?.Target ?? points.find(p => p.target != null)?.target ?? null;

            chart.setOption({
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
                xAxis: { type: 'value', min, max },
                yAxis: { type: 'value' },
                legend: { top: 0 },
                series: [
                    { type: 'bar', name: L.Hist, data: centers.map((c, i) => [c, counts[i]]), barWidth: '90%' },
                    { type: 'line', name: L.Fit, data: densityX.map((x, i) => [x, densityY[i]]), symbol: 'none' }
                ],
                markLine: {
                    symbol: 'none',
                    lineStyle: { type: 'dashed' },
                    label: { formatter: (p) => `${p.name} = ${(+p.value).toFixed(3)}` },
                    data: [
                        ...(lsl != null ? [{ xAxis: lsl, name: L.LSL }] : []),
                        ...(tgt != null ? [{ xAxis: tgt, name: '@Localizer["XR_Target"]' }] : []),
                        ...(usl != null ? [{ xAxis: usl, name: L.USL }] : [])
                    ]
                }
            });
        }


        function renderXRCapTable(cap) {
            const el = document.getElementById('capTableXR');
            if (!cap) { el.innerHTML = `<em>${L.NoCapData}</em>`; return; }

            const safe = v => (v == null || isNaN(v)) ? '—' : Number(v).toFixed(3);
            el.innerHTML = `
              <div class="table-responsive">
                <table class="table table-sm align-middle mb-0">
                  <thead>
                    <tr>
                      <th>${L.tbl_Variable}</th><th>${L.tbl_n}</th><th>${L.tbl_Subgroups}</th>
                      <th>${L.tbl_Mean}</th><th>${L.tbl_SigmaOverall}</th><th>${L.tbl_SigmaWithin}</th>
                      <th>${L.tbl_LSL}</th><th>${L.tbl_USL}</th><th>${L.tbl_Cp}</th><th>${L.tbl_Cpk}</th><th>${L.tbl_Pp}</th><th>${L.tbl_Ppk}</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>${cap.controlOperationName ?? cap.controlOperation ?? ''}</td>
                      <td>${cap.nPoints ?? '—'}</td>
                      <td>${cap.nSubgroups ?? '—'}</td>
                      <td>${safe(cap.meanAll)}</td>
                      <td>${safe(cap.sigmaOverall)}</td>
                      <td>${safe(cap.sigmaWithin)}</td>
                      <td>${cap.LSL ?? '—'}</td>
                      <td>${cap.USL ?? '—'}</td>
                      <td>${safe(cap.Cp)}</td>
                      <td>${safe(cap.Cpk)}</td>
                      <td>${safe(cap.Pp)}</td>
                      <td>${safe(cap.Ppk)}</td>
                    </tr>
                  </tbody>
                </table>
              </div>`;
        }

        function renderXbarChart(xbarData, ctrl, specOrLsl, maybeUsl) {
            const chart = ec('xbarXR');
            const x = xbarData.map(d => d.idx);
            const y = xbarData.map(d => d.mean);

            // compatibilidad hacia atrás
            let spec = null, lsl = null, usl = null;
            if (specOrLsl && typeof specOrLsl === 'object' && !Array.isArray(specOrLsl)) {
                spec = specOrLsl;
                lsl = spec?.LSL ?? null;
                usl = spec?.USL ?? null;
            } else {
                lsl = specOrLsl ?? null;
                usl = maybeUsl ?? null;
            }
            const tgt = spec?.Target ?? null;

            chart.setOption({
                tooltip: { trigger: 'axis' },
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'category', data: x, name: L.Subgroup },
                yAxis: { type: 'value', scale: true },
                legend: { top: 0 },
                series: [
                    { type: 'line', name: 'X̄', data: y, showSymbol: true, areaStyle: { opacity: .06 } },
                    { type: 'line', name: 'CL', data: y.map(() => ctrl.CL), symbol: 'none' },
                    { type: 'line', name: 'UCL', data: y.map(() => ctrl.UCL), symbol: 'none', lineStyle: { type: 'dashed' } },
                    { type: 'line', name: 'LCL', data: y.map(() => ctrl.LCL), symbol: 'none', lineStyle: { type: 'dashed' } },
                    ...(lsl != null ? [{ type: 'line', name: L.LSL, data: y.map(() => lsl), symbol: 'none', lineStyle: { type: 'dotted' } }] : []),
                    ...(tgt != null ? [{ type: 'line', name: '@Localizer["XR_Target"]', data: y.map(() => tgt), symbol: 'none', lineStyle: { type: 'dotted' } }] : []),
                    ...(usl != null ? [{ type: 'line', name: L.USL, data: y.map(() => usl), symbol: 'none', lineStyle: { type: 'dotted' } }] : [])
                ],
                // Etiquetas numéricas de LSL/Target/USL (al estilo del ejemplo)
                markLine: {
                    symbol: 'none',
                    lineStyle: { type: 'dotted' },
                    label: { formatter: (p) => `${p.name} = ${(+p.value).toFixed(3)}` },
                    data: [
                        ...(lsl != null ? [{ yAxis: lsl, name: L.LSL }] : []),
                        ...(tgt != null ? [{ yAxis: tgt, name: '@Localizer["XR_Target"]' }] : []),
                        ...(usl != null ? [{ yAxis: usl, name: L.USL }] : [])
                    ]
                }
            });
        }


        function renderRChart(rData, ctrl) {
            const chart = echarts.init(document.getElementById('rchartXR'));
            const x = rData.map(d => d.idx);
            const y = rData.map(d => d.r);
            chart.setOption({
                tooltip: { trigger: 'axis' },
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'category', data: x, name: L.Subgroup },
                yAxis: { type: 'value', min: 0, scale: true },
                legend: { top: 0 },
                series: [
                    { type: 'line', name: 'R', data: y, showSymbol: true, areaStyle: { opacity: .06 } },
                    { type: 'line', name: 'CL', data: y.map(() => ctrl.CL), symbol: 'none' },
                    { type: 'line', name: 'UCL', data: y.map(() => ctrl.UCL), symbol: 'none', lineStyle: { type: 'dashed' } },
                    { type: 'line', name: 'LCL', data: y.map(() => ctrl.LCL), symbol: 'none', lineStyle: { type: 'dashed' } }
                ]
            });
        }

        function renderRunChart(items, lsl, usl) {
            const dom = document.getElementById('runXR');
            const chart = echarts.init(dom);
            chart.setOption({
                tooltip: { trigger: 'axis' },
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'time' },
                yAxis: { type: 'value', scale: true },
                legend: { top: 0 },
                series: [
                    { type: 'scatter', name: L.Result, data: items.map(p => [p.ts, p.y]) },
                    ...(lsl != null ? [{ type: 'line', name: L.LSL, data: items.map(p => [p.ts, lsl]), lineStyle: { type: 'dashed' }, symbol: 'none' }] : []),
                    ...(usl != null ? [{ type: 'line', name: L.USL, data: items.map(p => [p.ts, usl]), lineStyle: { type: 'dashed' }, symbol: 'none' }] : [])
                ]
            });
        }

        function renderNormalProb(items, lsl, usl) {
            const dom = document.getElementById('normprobXR');
            const chart = echarts.init(dom);
            const vals = items.map(p => p.y).filter(Number.isFinite).sort((a, b) => a - b);
            if (vals.length < 3) { chart.clear(); return; }

            const pts = vals.map((v, i) => {
                const p = (i + 0.375) / (vals.length + 0.25);
                return [normInv(p), v]; // (z, y)
            });

            // regresión lineal y = a + b z
            const n = pts.length;
            const mx = mean(pts.map(p => p[0]));
            const my = mean(pts.map(p => p[1]));
            const cov = pts.reduce((s, p) => s + (p[0] - mx) * (p[1] - my), 0) / n;
            const vx = pts.reduce((s, p) => s + (p[0] - mx) * (p[0] - mx), 0) / n;
            const b = cov / vx;
            const a = my - b * mx;

            const xs = [pts[0][0], pts[pts.length - 1][0]];
            const line = xs.map(x => [x, a + b * x]);

            chart.setOption({
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                grid: { left: 48, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'value', name: 'z' },
                yAxis: { type: 'value', name: L.Result, scale: true },
                legend: { top: 0 },
                series: [
                    { type: 'scatter', data: pts, name: L.Data },
                    { type: 'line', data: line, name: L.Fit, symbol: 'none' },
                    ...(lsl != null ? [{ type: 'line', data: xs.map(x => [x, lsl]), name: L.LSL, lineStyle: { type: 'dashed' }, symbol: 'none' }] : []),
                    ...(usl != null ? [{ type: 'line', data: xs.map(x => [x, usl]), name: L.USL, lineStyle: { type: 'dashed' }, symbol: 'none' }] : [])
                ]
            });
        }

        function renderCapabilityPlot(cap, lsl, usl) {
            const dom = document.getElementById('capPlotXR');
            const chart = echarts.init(dom);
            if (!cap) { chart.clear(); return; }

            const mu = Number(cap.meanAll ?? NaN);
            const sW = Number(cap.sigmaWithin ?? NaN);
            const sO = Number(cap.sigmaOverall ?? NaN);

            function band(mu, s) { return [mu - 3 * s, mu, mu + 3 * s]; }

            const cat = [L.WithinBand, L.OverallBand];
            const within = (isNaN(sW) ? [null, null, null] : band(mu, sW));
            const overall = (isNaN(sO) ? [null, null, null] : band(mu, sO));

            const minX = Math.min((lsl != null ? lsl : mu - 4 * (sO || sW || 1)), within[0] ?? Infinity, overall[0] ?? Infinity);
            const maxX = Math.max((usl != null ? usl : mu + 4 * (sO || sW || 1)), within[2] ?? -Infinity, overall[2] ?? -Infinity);

            chart.setOption({
                tooltip: { trigger: 'axis' },
                grid: { left: 64, right: 16, top: 24, bottom: 40 },
                xAxis: { type: 'value', min: minX, max: maxX },
                yAxis: { type: 'category', data: cat },
                legend: { top: 0 },
                series: [
                    {
                        type: 'custom', name: '±3σ',
                        renderItem: (params, api) => {
                            const y = api.value(0);
                            const yCoord = api.coord([minX, y])[1];
                            const x1 = api.coord([api.value(1), y])[0];
                            const x2 = api.coord([api.value(3), y])[0];
                            const xc = api.coord([api.value(2), y])[0];
                            return {
                                type: 'group',
                                children: [
                                    { type: 'rect', shape: { x: Math.min(x1, x2), y: yCoord - 8, width: Math.abs(x2 - x1), height: 16 }, style: { opacity: .15 } },
                                    { type: 'line', shape: { x1: xc, y1: yCoord - 10, x2: xc, y2: yCoord + 10 }, style: { width: 2 } }
                                ]
                            };
                        },
                        data: [
                            [0, within[0], within[1], within[2]],
                            [1, overall[0], overall[1], overall[2]]
                        ]
                    },
                    ...(lsl != null ? [{ type: 'line', name: L.LSL, data: [[minX, -0.5], [minX, 1.5]].map(p => [lsl, p[1]]), symbol: 'none', lineStyle: { type: 'dashed' } }] : []),
                    ...(usl != null ? [{ type: 'line', name: L.USL, data: [[maxX, -0.5], [maxX, 1.5]].map(p => [usl, p[1]]), symbol: 'none', lineStyle: { type: 'dashed' } }] : []),
                ]
            });
        }

        // Re-render/resize cuando se muestre la pestaña "Más análisis"
        document.addEventListener('shown.bs.tab', function (e) {
          const target = e.target && e.target.getAttribute('data-bs-target');
          if (target !== '#pane-analisis') return;

          // Opción rápida: si ya existen instancias, solo resize
          ['xbarXR','rchartXR','runXR','normprobXR','capPlotXR'].forEach(id => {
            const inst = echarts.getInstanceByDom(document.getElementById(id));
            if (inst) inst.resize();
          });

          // Si aún no hay instancias válidas (porque se crearon ocultas con 0 px),
          // re-renderiza usando el último dataset cacheado.
          if (window._xr_last) {
            const { items, spec, xbarData, rData, ctrlX, ctrlR, LSL, USL, cap } = window._xr_last;
            // Vuelve a pintar los de la pestaña 2
            renderXbarChart(xbarData, ctrlX, spec);
            renderRChart(rData, ctrlR);
            renderRunChart(items, LSL, USL);
            renderNormalProb(items, LSL, USL);
            renderCapabilityPlot(cap, LSL, USL);
          }
        });

        window.addEventListener('resize', () => {
            ['xbarXR', 'rchartXR', 'runXR', 'normprobXR', 'capPlotXR', 'chartXR', 'histXR', 'cpkChart'].forEach(id => {
                const inst = echarts.getInstanceByDom(document.getElementById(id));
                if (inst) inst.resize();
            });
        });

        // Limpia combos dependientes
        function resetAfterCountry() {
            $("#line").empty().append(`<option value="">${L.Line}</option>`);
            $("#sku").empty().append(`<option value="">${L.SKU}</option>`);
            resetYAndX();
        }
        function resetAfterPlant() {
            $("#sku").empty().append(`<option value="">${L.SKU}</option>`);
            resetYAndX();
        }

        // País → llena plantas y limpia lo demás
        document.getElementById('pais').addEventListener('change', function () {
            fillPlants(this.value);        // ya la tienes hecha
            resetAfterCountry();           // limpia línea, sku, Y/X
        });

        // Planta → cargar líneas de esa planta (company)
        $("#planta").on("change", function () {
            const companyId = this.value;  // valor = Company (ej. "001")
            resetAfterPlant();

            if (!companyId) {
                $("#line").empty().append(`<option value="">${L.Line}</option>`);
                return;
            }

            $.ajax({
                url: '@Url.Action("ObtenerLineas_XR", "XRcharts")',
                type: 'GET',
                data: { company: companyId },
                success: function (data) {
                    console.log('Lineas payload:', data);
                    // 👇 Acepta tanto {result:[...]} como [...] o { $values:[...]}
                    const payload = (data && data.result) ? data.result : data;
                    const lines = toArray(payload);

                    const $line = $("#line");
                    $line.empty().append(`<option value="">${L.Line}</option>`);

                    lines
                        .sort((a, b) => (a.workplaceName || a.name || '').localeCompare((b.workplaceName || b.name || ''), 'es'))
                        .forEach(l => {
                            const id = l.workplace ?? l.id;
                            const name = l.workplaceName ?? l.name ?? id;
                            if (id) $line.append(new Option(name, id));
                        });

                    if (lines.length) {
                        $line.val(lines[0].workplace ?? lines[0].id).trigger('change');
                    }
                },
                error: function (xhr) {
                    console.error("ObtenerLineas_XR error", xhr);
                    $("#line").empty().append(`<option value="">${L.Line}</option>`);
                }
            });

        });

        // Cuando cambie la línea, ya tienes esto para cargar SKUs:
        $("#line, #startDate, #endDate").on("change", cargarProductos);


        // ---------- helpers estadísticos ----------
        function mean(a) { return a.reduce((s, v) => s + v, 0) / a.length; }
        function range(a) { return Math.max(...a) - Math.min(...a); }
        function normInv(p) {
            p = Math.min(Math.max(p, 1e-12), 1 - 1e-12);
            const a = [-39.69683028665376, 220.9460984245205, -275.9285104469687, 138.3577518672690, -30.66479806614716, 2.506628277459239];
            const b = [-54.47609879822406, 161.5858368580409, -155.6989798598866, 66.80131188771972, -13.28068155288572];
            const c = [-0.007784894002430293, -0.3223964580411365, -2.400758277161838, -2.549732539343734, 4.374664141464968, 2.938163982698783];
            const d = [0.007784695709041462, 0.3224671290700398, 2.445134137142996, 3.754408661907416];
            let q, r;
            if (p < 0.02425) {
                q = Math.sqrt(-2 * Math.log(p));
                return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                    ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            } else if (p > 1 - 0.02425) {
                q = Math.sqrt(-2 * Math.log(1 - p));
                return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                    ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            } else {
                q = p - 0.5; r = q * q;
                return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
                    (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
            }
        }

        // ====== Constantes de control para Xbar-R ======
        const XR_CONST = {
            2: { A2: 1.880, D3: 0.000, D4: 3.267 },
            3: { A2: 1.023, D3: 0.000, D4: 2.574 },
            4: { A2: 0.729, D3: 0.000, D4: 2.282 },
            5: { A2: 0.577, D3: 0.000, D4: 2.114 },
            6: { A2: 0.483, D3: 0.000, D4: 2.004 },
            7: { A2: 0.419, D3: 0.076, D4: 1.924 },
            8: { A2: 0.373, D3: 0.136, D4: 1.864 },
            9: { A2: 0.337, D3: 0.184, D4: 1.816 },
            10: { A2: 0.308, D3: 0.223, D4: 1.777 }
        };

        function avg(a) { return a.reduce((s, v) => s + v, 0) / a.length; }
        function rbar(groups) { return avg(groups.map(g => Math.max(...g) - Math.min(...g))); }
        function xbarbar(groups) { return avg(groups.map(g => avg(g))); }


        // =======================
        // CPK INTERACTIVO (outliers + chart + KPIs)
        // Requiere: echarts, items [{ts,y,lsl,usl,target}], objeto spec {LSL,USL,Target}
        // =======================
        let _cpk = {
            showRemoved: false,
            method: 'none', // 'none' | 'z' | 'iqr'
            zth: 3,
            iqrk: 1.5,
            chart: null,
            inited: false,
            manualExcluded: new Set(), // << NUEVO: guarda sg (ids) excluidos manualmente
        };

        function cpkYRange(values, mean, sd, LSL, USL) {
          const fin = values.filter(v => Number.isFinite(v));
          let lo = Math.min(...fin), hi = Math.max(...fin);

          if (Number.isFinite(sd) && sd > 0) {
            lo = Math.min(lo, mean - 3*sd);
            hi = Math.max(hi, mean + 3*sd);
          }
          if (LSL != null) lo = Math.min(lo, LSL);
          if (USL != null) hi = Math.max(hi, USL);

          if (!Number.isFinite(lo) || !Number.isFinite(hi)) { lo = 0; hi = 1; }
          const pad = (hi - lo) * 0.08 || 0.1; // margen 8% (fallback 0.1)
          return [lo - pad, hi + pad];
        }


        // ----- utilidades cpk -----
        function cpkMean(a) { return a.reduce((s, v) => s + v, 0) / a.length; }
        function cpkStdSample(a) { // muestral
            if (a.length < 2) return 0;
            const m = cpkMean(a);
            const v = a.reduce((s, x) => s + (x - m) * (x - m), 0) / (a.length - 1);
            return Math.sqrt(v);
        }
        function cpkQuantile(sorted, q) {
            const pos = (sorted.length - 1) * q;
            const base = Math.floor(pos);
            const rest = pos - base;
            if (sorted[base + 1] !== undefined) return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
            return sorted[base];
        }
        function cpkFilterIQR(arr, k) {
            const s = [...arr].sort((a, b) => a - b);
            const q1 = cpkQuantile(s, 0.25), q3 = cpkQuantile(s, 0.75);
            const iqr = q3 - q1;
            const lo = q1 - k * iqr, hi = q3 + k * iqr;
            const keep = arr.map(v => v >= lo && v <= hi);
            return { keep, bounds: [lo, hi] };
        }
        function cpkFilterZ(arr, z) {
            const m = cpkMean(arr), sd = cpkStdSample(arr);
            if (sd === 0) return { keep: arr.map(_ => true), bounds: [m, m] };
            const keep = arr.map(v => Math.abs((v - m) / sd) <= z);
            return { keep, bounds: [m - z * sd, m + z * sd] };
        }

        // calcula Cp/Cpk con manejo de casos 2 lados / 1 lado / sin specs
        function cpkCalcStats(values, LSL, USL) {
            if (!values.length) return { n: 0, mean: NaN, sd: NaN, cp: NaN, cpk: NaN };
            const m = cpkMean(values);
            const sd = cpkStdSample(values);
            let cp = NaN, cpk = NaN;

            if (Number.isFinite(sd) && sd > 0) {
                const cpu = (USL != null) ? (USL - m) / (3 * sd) : NaN;
                const cpl = (LSL != null) ? (m - LSL) / (3 * sd) : NaN;

                if (USL != null && LSL != null) {
                    cp = (USL - LSL) / (6 * sd);
                    cpk = Math.min(cpu, cpl);
                } else if (USL != null) {
                    // un solo lado: reporta cpu como Cpk (práctica común)
                    cpk = cpu;
                } else if (LSL != null) {
                    cpk = cpl;
                }
            }
            return { n: values.length, mean: m, sd, cp, cpk };
        }

        function cpkSafe(v, digits = 3) {
            return (v == null || !isFinite(v)) ? '—' : Number(v).toFixed(digits);
        }

        // ----- init de controles (solo una vez) -----
        function initCpkModule() {
            if (_cpk.inited) return;
            _cpk.inited = true;

            // toggle de controles según método
            const $method = $('#cpkMethod'), $zWrap = $('#cpkZWrap'), $iqrWrap = $('#cpkIqrWrap');
            $method.on('change', () => {
                _cpk.method = $method.val();
                $zWrap.toggle(_cpk.method === 'z');
                $iqrWrap.toggle(_cpk.method === 'iqr');
            });

            $('#cpkZ').on('input', () => { _cpk.zth = Number($('#cpkZ').val() || 3); });
            $('#cpkIqrK').on('input', () => { _cpk.iqrk = Number($('#cpkIqrK').val() || 1.5); });

            $('#cpkToggleRemoved').on('click', () => {
                _cpk.showRemoved = !_cpk.showRemoved;

                // Cambia el texto del botón
                $('#cpkToggleRemoved').text(
                    _cpk.showRemoved
                        ? (L.HideFiltered || 'Hide filtered points')
                        : (L.ShowFiltered || 'Show filtered points')
                );

                // Vuelve a dibujar para mostrar/ocultar la serie "Filtrados"
                if (window._cpk_last) {
                    renderCpkInteractive(window._cpk_last.items, window._cpk_last.spec);
                }
            });


            _cpk.chart = echarts.init(document.getElementById('cpkChart'), null, { renderer: 'svg' });

            // botón calcular (re-render usando último dataset cacheado)
            $('#cpkRun').on('click', () => {
                if (window._cpk_last) renderCpkInteractive(window._cpk_last.items, window._cpk_last.spec);
            });

            // estado inicial
            $method.val('none').trigger('change');

            $('#cpkResetManual').on('click', () => {
                _cpk.manualExcluded.clear();   // limpia los manuales
                $('#cpkManualBadge').text('Excluidos: 0');

                // Resetear el dropdown correcto
                $('#cpkMethod').val('none').trigger('change');
                $('#cpkZ').val('2');    // umbral default
                $('#cpkIqrK').val('1.5');

                renderCpkInteractive(window._cpk_last.items, window._cpk_last.spec);
            });

            $('#cpkResetZoom').on('click', () => {
                // Resetea sliders al 100% y vuelve a ajustar Y a la franja de datos actual
                _cpk.chart.dispatchAction({ type: 'dataZoom', start: 0, end: 100 });            // X
                _cpk.chart.dispatchAction({ type: 'dataZoom', yAxisIndex: 0, start: 0, end: 100 }); // Y
                if (window._cpk_last) renderCpkInteractive(window._cpk_last.items, window._cpk_last.spec);
            });

        }

        function ec(id) {
            const el = document.getElementById(id);
            return echarts.getInstanceByDom(el) || echarts.init(el);
        }
        // ----- render principal -----
        function renderCpkInteractive(items, spec) {
            if (!_cpk.inited) initCpkModule();
            window._cpk_last = { items, spec }; // cache para botón "Calcular"

            const LSL = spec?.LSL ?? items.find(p => p.lsl != null)?.lsl ?? null;
            const USL = spec?.USL ?? items.find(p => p.usl != null)?.usl ?? null;

            const raw = items.map(p => p.y);
            const idx = items.map((_, i) => i + 1);
            const sgIds = items.map((p, i) => p.sg || i); // usar el índice del map


            // --- filtro automático (none/z/iqr)
            let autoKeep = raw.map(_ => true), bounds = null;
            if (_cpk.method === 'z') {
                const r = cpkFilterZ(raw, _cpk.zth); autoKeep = r.keep; bounds = r.bounds;
            } else if (_cpk.method === 'iqr') {
                const r = cpkFilterIQR(raw, _cpk.iqrk); autoKeep = r.keep; bounds = r.bounds;
            }

            // --- filtro manual por sg
            const manKeep = sgIds.map(id => !_cpk.manualExcluded.has(id));

            // --- máscara final = auto AND manual
            const keepMask = autoKeep.map((k, i) => k && manKeep[i]);

            const used = raw.filter((v, i) => keepMask[i]);
            const removed = raw
                .map((v, i) => ({ v, i, id: sgIds[i], reason: _cpk.manualExcluded.has(sgIds[i]) ? 'manual' : 'auto' }))
                .filter((_, i) => !keepMask[i]);

            // métricas (tal como ya haces)
            const sRaw = cpkCalcStats(raw, LSL, USL);
            const sUse = cpkCalcStats(used, LSL, USL);

            const [ymin, ymax] = cpkYRange(used, sUse.mean, sUse.sd, LSL, USL);


            // --- Detectar violaciones de Run Rules sobre los puntos USADOS (keepMask) ---
            const rr = detectRunRules(raw, keepMask, sUse.mean, sUse.sd);

            // Mapa para tooltip (qué reglas tiene cada índice)
            const ruleNames = { r1: 'Rule #1', r2: 'Rule #2', r3: 'Rule #3', r4: 'Rule #4', r5: 'Rule #5' };
            const ruleMap = {};
            Object.entries(rr).forEach(([key, set]) => {
                set.forEach(i => {
                    if (!ruleMap[i]) ruleMap[i] = [];
                    ruleMap[i].push(ruleNames[key]);
                });
            });


            // KPIs (tus elementos existentes)
            $('#cpk_nTotal').text(sRaw.n);
            $('#cpk_nUsed').text(used.length);
            $('#cpk_mean').text(cpkSafe(sUse.mean, 4));
            $('#cpk_std').text(cpkSafe(sUse.sd, 4));
            $('#cpk_cp').text(cpkSafe(sUse.cp));
            $('#cpk_cpk').text(cpkSafe(sUse.cpk));
            $('#cpk_raw').text(cpkSafe(sRaw.cpk));
            $('#cpk_filtered').text(cpkSafe(sUse.cpk));

            // líneas base
            const meanLine = used.length ? new Array(raw.length).fill(sUse.mean) : [];
            const lslArr = LSL != null ? new Array(raw.length).fill(LSL) : null;
            const uslArr = USL != null ? new Array(raw.length).fill(USL) : null;

            // series (pinta excluidos automáticos como null y, si activas showRemoved, en un scatter aparte)
            const series = [
                {
                    name: (L.Data || 'Datos') + ' (' + (L?.Used || 'usados') + ')',
                    type: 'line',
                    data: raw.map((v, i) => keepMask[i] ? v : null),
                    symbol: 'circle', showSymbol: true, lineStyle: { width: 2 }, z: 3
                },
                {
                    name: (L?.Mean || 'Media') + ' (sin outliers)',
                    type: 'line',
                    data: meanLine,
                    symbol: 'none',
                    lineStyle: { width: 2, type: 'dashed' }, z: 2
                }
            ];

            // helper para construir data [idx, valor] desde un Set de índices
            const ruleData = (set) => [...set].map(i => [i + 1, raw[i]]);

            // Overlays por regla (símbolo/color distintos)
            if (rr.r1.size) series.push({
                name: 'Rule #1 (fuera ±3σ)',
                type: 'scatter', data: ruleData(rr.r1), z: 5,
                symbol: 'x', symbolSize: 14, itemStyle: { color: '#e11d48' }
            });
            if (rr.r2.size) series.push({
                name: 'Rule #2 (2 de 3 en Zona A)',
                type: 'scatter', data: ruleData(rr.r2), z: 5,
                symbol: 'triangle', symbolSize: 12, itemStyle: { color: '#f97316' }
            });
            if (rr.r3.size) series.push({
                name: 'Rule #3 (4 de 5 en Zona B)',
                type: 'scatter', data: ruleData(rr.r3), z: 5,
                symbol: 'rect', symbolSize: 12, itemStyle: { color: '#facc15' }
            });
            if (rr.r4.size) series.push({
                name: 'Rule #4 (≥8 del mismo lado)',
                type: 'scatter', data: ruleData(rr.r4), z: 5,
                symbol: 'diamond', symbolSize: 12, itemStyle: { color: '#8b5cf6' }
            });
            if (rr.r5.size) series.push({
                name: 'Rule #5 (≥6 en tendencia)',
                type: 'scatter', data: ruleData(rr.r5), z: 5,
                symbol: 'pin', symbolSize: 12, itemStyle: { color: '#0ea5e9' }
            });


            if (LSL != null) series.push({ name: L.LSL, type: 'line', data: lslArr, symbol: 'none', lineStyle: { width: 2 }, z: 1 });
            if (USL != null) series.push({ name: L.USL, type: 'line', data: uslArr, symbol: 'none', lineStyle: { width: 2 }, z: 1 });

            // Mostrar “filtrados” (auto+manual)
            if (_cpk.showRemoved && removed.length) {
                series.push({
                    name: (L?.ShowFiltered || 'Filtrados'),
                    type: 'scatter',
                    data: removed.map(o => [o.i + 1, o.v]),
                    symbolSize: 10
                });
            }


            // bandas opcionales (método)
            let markArea = undefined;
            if (bounds) {
                const bands = [];
                if (LSL != null) bands.push([{ yAxis: bounds[0] }, { yAxis: LSL }]);
                if (USL != null) bands.push([{ yAxis: USL }, { yAxis: bounds[1] }]);
                markArea = { silent: true, itemStyle: { color: 'rgba(148,163,184,0.10)' }, data: bands };
            }

            const zonesSeries = cpkZonesMarkArea(sUse.mean, sUse.sd) || [];

            // --- Entradas “falsas” para que la leyenda muestre ±1σ / ±2σ / ±3σ
            const legendBands = [
                {
                    name: '±1σ', type: 'line', data: [], showSymbol: false,
                    lineStyle: { width: 10, color: 'rgba(52, 199, 89, 0.9)' }, // verde vivo
                    itemStyle: { color: 'rgba(52, 199, 89, 0.9)' }
                },
                {
                    name: '±2σ', type: 'line', data: [], showSymbol: false,
                    lineStyle: { width: 10, color: 'rgba(255, 204, 0, 0.95)' }, // amarillo vivo
                    itemStyle: { color: 'rgba(255, 204, 0, 0.95)' }
                },
                {
                    name: '±3σ', type: 'line', data: [], showSymbol: false,
                    lineStyle: { width: 10, color: 'rgba(255, 59, 48, 0.95)' }, // rojo vivo
                    itemStyle: { color: 'rgba(255, 59, 48, 0.95)' }
                },
            ];


            _cpk.chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    formatter: (params) => {
                        // params = array de puntos bajo el mismo x (idx)
                        if (!params || !params.length) return '';
                        const i = params[0].dataIndex; // índice base
                        const lines = [];
                        lines.push(`${i + 1}`);
                        params.forEach(p => {
                            const val = (Array.isArray(p.data) ? p.data[1] : p.data);
                            const valTxt = (val == null || isNaN(val)) ? '—' : Number(val).toFixed(4);
                            lines.push(`${p.marker} ${p.seriesName}: ${valTxt}`);
                        });
                        if (ruleMap[i]?.length) {
                            lines.push(`<span style="color:#ef4444">⚠ ${ruleMap[i].join(', ')}</span>`);
                        }
                        return lines.join('<br/>');
                    }
                },
                legend: { top: 0 },
                xAxis: { type: 'category', data: idx, name: L.Subgroup || 'Muestra' },
                yAxis: { type: 'value', name: L.Result, min: ymin, max: ymax, scale: true },
                // <<< NUEVO: dataZoom para zoom/pan con mouse y sliders >>>
                grid: { left: 50, right: 28, top: 40, bottom: 60 }, // más margen para que no tape el slider vertical
                dataZoom: [
                    // X (mouse + slider)
                    { type: 'inside', xAxisIndex: 0, filterMode: 'none', zoomOnMouseWheel: true, moveOnMouseWheel: true, moveOnMouseMove: true },
                    { type: 'slider', xAxisIndex: 0, height: 16, bottom: 8, showDataShadow: false, realtime: true },

                    // Y (mouse + slider)
                    { type: 'inside', yAxisIndex: 0, filterMode: 'none', zoomOnMouseWheel: true, moveOnMouseWheel: true, moveOnMouseMove: true },
                    { type: 'slider', yAxisIndex: 0, width: 14, right: 8, showDataShadow: false, realtime: true }
                ],

                series: [
                    ...zonesSeries,     // las franjas con labels
                    ...series,//,          // tus series de datos
                    ...legendBands      // “iconos” para la leyenda
                ]
            });



            _cpk.chart.off('click'); // evita múltiples handlers
            _cpk.chart.on('click', params => {
                // Solo actúa si se clicó la serie principal de datos (no líneas LSL/USL/Mean)
                if (!params || !params.seriesName) return;
                if (!/Datos|Data/i.test(params.seriesName)) return;

                const i = params.dataIndex;
                if (i == null || !window._cpk_last) return;

                const sg = window._cpk_last.items[i]?.sg; // usas tu campo sg del dataset
                if (!sg) return;

                if (_cpk.manualExcluded.has(sg)) _cpk.manualExcluded.delete(sg);
                else _cpk.manualExcluded.add(sg);

                $('#cpkManualBadge').text(`Excluidos: ${_cpk.manualExcluded.size}`);
                renderCpkInteractive(window._cpk_last.items, window._cpk_last.spec);
            });
        }

    </script>
}
