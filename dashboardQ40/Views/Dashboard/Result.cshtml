@using Newtonsoft.Json
@using System.Collections.Generic
@inject Microsoft.Extensions.Localization.IStringLocalizer Localizer

@{
    ViewData["Title"] = Localizer["Result_Title"]; // "Quality Chart with Alerts"
    var data = ViewBag.Data;
    var allCandlestickData = ViewBag.AllCandlestickData as Dictionary<string, List<double[]>>;
    var variableYName = ViewBag.VariableYName as string;
    var variablesXData = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var selectedXVariables = ViewBag.SelectedXVariables as List<string>;
}

@{
    double minThreshold = ViewBag.MinThreshold ?? 0;
    double maxThreshold = ViewBag.MaxThreshold ?? 100;
}

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>

<style>
    .container-flex {
        display: flex;
        flex-direction: row;
        gap: 20px;
        align-items: flex-start;
    }

    #data-table {
        border-collapse: collapse;
        width: 250px;
    }

        #data-table th, #data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        #data-table th {
            background-color: #2c82c9;
            color: white;
        }

    #chart-container {
        flex-grow: 1;
        height: 600px;
    }

    .container-campana {
        display: flex;
        flex-direction: row; /* 📌 Alinear en fila */
        justify-content: space-between;
        align-items: flex-start;
        margin-top: 20px;
    }


    .leyenda-campana {
        width: 250px;
        padding: 10px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        font-size: 14px;
    }

    #bell-curve-container {
        flex-grow: 1;
        height: 400px;
        position: relative; /* Necesario para posicionar el loader */
    }

    @@keyframes pulse {
    0% { opacity: 0.5; }
    50% { opacity: 1; }
    100% { opacity: 0.5; }
}

#bell-curve-loader {
    animation: pulse 1.5s infinite;
}

    #loaderOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.9);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .loaderContent {
        text-align: center;
    }

    .bubbles {
        width: 50px;
        height: 50px;
        margin: auto;
        position: relative;
    }

        .bubbles::before,
        .bubbles::after {
            content: "";
            position: absolute;
            border-radius: 50%;
            animation: bubble 1s infinite ease-in-out;
        }

        .bubbles::before {
            width: 20px;
            height: 20px;
            background-color: #e11d48;
            left: 0;
        }

        .bubbles::after {
            width: 20px;
            height: 20px;
            background-color: #0284c7;
            right: 0;
            animation-delay: 0.5s;
        }

    @@keyframes bubble {
        0%, 100% {
            transform: translateY(0);
            opacity: 0.7;
        }

        50% {
            transform: translateY(-15px);
            opacity: 1;
        }
    }

    .loaderText {
        margin-top: 10px;
        font-size: 1rem;
        color: #333;
        font-weight: 500;
    }
</style>
<div class="container-flex">
    <div id="loaderOverlay">
        <div class="loaderContent">
            <div class="bubbles"></div>
            <p class="loaderText">@Localizer["Loader_Analyzing"]</p>
        </div>
    </div>

    <div id="chart-container"></div>
</div>

<div class="container-campana" style="display:flex; align-items:center; gap:10px;">
    <div id="bell-curve-container" style="width:75%; height:350px;"></div>

    <div class="leyenda-campana" style="width:15%; padding:8px; border:1px solid #ccc; border-radius:5px; font-size:12px; text-align:left;">
        <h4 style="margin:0 0 5px 0; font-size:14px;">@Localizer["Stats_Title"]</h4>
        <p><b>@Localizer["Stats_Cpk"]:</b> <span id="cpkValue">-</span></p>
        <p><b>@Localizer["Stats_Ppk"]:</b> <span id="ppkValue">-</span></p>
        <p><b>@Localizer["Stats_Mean"]:</b> <span id="meanValue">-</span></p>
        <p><b>@Localizer["Stats_Range"]:</b> <span id="rangeValue">-</span></p>

        <div style="margin-top:5px; display:flex; justify-content:center; gap:5px;">
            <button onclick="zoomOut()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_Out_Title"]">🔍➖</button>
            <button onclick="zoomIn()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_In_Title"]">🔍➕</button>
            <button onclick="resetZoom()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_Reset_Title"]">🔄</button>
        </div>
    </div>

    <div id="bell-curve-loader" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:10; background:rgba(255,255,255,.9); padding:20px; border-radius:12px; box-shadow:0 0 12px rgba(0,0,0,.15); text-align:center;">
        <svg width="50" height="50" viewBox="0 0 50 50">
            <circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="90" stroke-dashoffset="0">
                <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" from="0 25 25" to="360 25 25" />
            </circle>
        </svg>
        <div style="margin-top:10px; font-size:14px; color:#333;">@Localizer["Bell_Loading"]</div>
    </div>
</div>

<script>
    function toggleTable() { const c = document.getElementById('dataTableContainer'); c.style.display = c.style.display === "none" ? "block" : "none"; }
</script>

<button onclick="toggleTable()" style="margin-top:10px; padding:5px 10px;">📊 @Localizer["Button_ShowTable"]</button>

<div id="dataTableContainer" style="display:none; margin-top:15px;">
    <table id="dataTable" border="1" style="width:100%; text-align:center; border-collapse:collapse;">
        <thead>
            <tr>
                <th>@Localizer["Table_DateTime"]</th>
                <th>@ViewBag.VariableYName</th>
                @foreach (var xVar in ViewBag.VariablesXData.Keys)
                {
                    <th>@xVar</th>
                }
            </tr>
        </thead>
        <tbody>
            @for (int i = 0; i < ViewBag.Dates.Count; i++)
            {
                <tr>
                    <td>@ViewBag.Dates[i]</td>
                    <td>@(ViewBag.ScatterDataY.Count > i ? ((dynamic)ViewBag.ScatterDataY[i]).Value : "-")</td>
                    @foreach (var xVar in ViewBag.VariablesXData.Keys)
                    {
                        <td>@(ViewBag.VariablesXData[xVar].Count > i ? ViewBag.VariablesXData[xVar][i] : "-")</td>
                    }
                </tr>
            }
        </tbody>
    </table>
</div>

@{
    var datesJson = JsonConvert.SerializeObject(ViewBag.Dates ?? new List<string>());
    var scatterDataYJson = JsonConvert.SerializeObject(ViewBag.ScatterDataY ?? new List<object>());
    var variablesX = ViewBag.VariablesXData as Dictionary<string, List<double>> ?? new Dictionary<string, List<double>>();
    var scatterDataXJson = JsonConvert.SerializeObject(variablesX);
    var minTol = minThreshold;
    var maxTol = maxThreshold;
}

@section Scripts {
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

    <script>
        // Diccionario de textos para JS
        window.T = {
            Spec: '@Localizer["Tooltip_Spec"]',                    // "Spec"
            Mean: '@Localizer["Tooltip_Mean"]',                    // "Mean"
            MinLimit: '@Localizer["Tooltip_MinLimit"]',            // "Lower Spec Limit"
            MaxLimit: '@Localizer["Tooltip_MaxLimit"]',            // "Upper Spec Limit"
            Samples: '@Localizer["Tooltip_Samples"]',              // "Samples ({0})"
            XVARS: '@Localizer["Tooltip_XVars"]',                  // "X Variables"
            Bell_Title: '@Localizer["Bell_Title"]',                // "Normal Distribution - Variable"
            Bell_XAxis: '@Localizer["Bell_XAxis"]',                // "Variable"
            Bell_YAxis: '@Localizer["Bell_YAxis"]',                // "Frequency"
            Bell_Distribution: '@Localizer["Bell_Distribution"]',  // "Distribution"
            Bell_Histogram: '@Localizer["Bell_Histogram"]',        // "Histogram"
            Bell_LSL: '@Localizer["Bell_LSL"]',                    // "LSL"
            Bell_USL: '@Localizer["Bell_USL"]'                     // "USL"
        };

        const chart = echarts.init(document.getElementById('chart-container'));
        const bellCurveChart = echarts.init(document.getElementById('bell-curve-container'));

        window.addEventListener("load", function () {
            const loader = document.getElementById("loaderOverlay");
            if (loader) loader.style.display = "none";
        });

        const dates = @Html.Raw(datesJson);
        const scatterDataY = @Html.Raw(scatterDataYJson);
        const scatterDataX = @Html.Raw(scatterDataXJson);

        const VAR_Y_NAME = @Html.Raw(JsonConvert.SerializeObject(ViewBag.VariableYName ?? ""));
        const nombrePromedio = `${T.Mean} (${VAR_Y_NAME})`;
        const nombreMuestras = `Samples (${VAR_Y_NAME})`;

        const MIN_TOL = @minTol;
        const MAX_TOL = @maxTol;

        // ------- Preparación de datos -------
        const samplesByTime = {};
        (scatterDataY || []).forEach(entry => {
            const t = entry?.Time;
            const v = Number(entry?.Value);
            if (!t || isNaN(v)) return;
            if (!samplesByTime[t]) samplesByTime[t] = [];
            samplesByTime[t].push(v);
        });

        const xSet = new Set(Object.keys(samplesByTime));
        Object.keys(scatterDataX || {}).forEach(key => {
            const arr = scatterDataX[key] || [];
            arr.forEach((_, i) => { const d = dates[i]; if (d != null) xSet.add(d); });
        });
        const xCategories = Array.from(xSet).sort((a, b) => new Date(a) - new Date(b));

        const mean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;

        const meanSeriesData = Object.keys(samplesByTime)
            .sort((a, b) => new Date(a) - new Date(b))
            .map(t => [t, mean(samplesByTime[t])]);

        const allSamples = Object.values(samplesByTime).flat();
        const minY = (allSamples.length ? Math.min(...allSamples, MIN_TOL) : MIN_TOL) - 1;
        const maxY = (allSamples.length ? Math.max(...allSamples, MAX_TOL) : MAX_TOL) + 1;

        // ====== Control: toggles y helpers ======
        // 'data' => UCL/LCL = X̄ ± 3*σwithin ; 'cp' => alrededor de Target en base a Cp objetivo
        const CTRL_MODE = 'data';   // 'data' | 'cp'
        const CP_TARGET = 1.33;

        // d2 para sigmaWithin ≈ Rbar / d2 (por tamaño de subgrupo)
        const D2 = { 2: 1.128, 3: 1.693, 4: 2.059, 5: 2.326, 6: 2.534, 7: 2.704, 8: 2.847, 9: 2.970, 10: 3.078 };

        const stdPop = arr => {
            const m = mean(arr);
            return Math.sqrt(arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length);
        };

        function sigmaWithinFromSamples(samplesByTime) {
            const groups = Object.values(samplesByTime).filter(g => g && g.length);
            if (!groups.length) return null;
            const nList = groups.map(g => g.length);
            const nCount = nList.reduce((m, n) => ((m[n] = (m[n] || 0) + 1), m), {});
            const nModal = Number(Object.keys(nCount).sort((a, b) => nCount[b] - nCount[a])[0]) || 5;
            const d2 = D2[nModal] || D2[5];
            const Rbar = mean(groups.map(g => Math.max(...g) - Math.min(...g)));
            return d2 ? (Rbar / d2) : null;
        }

        // Target (nominal): si no viene, usar punto medio de especificación
        const TARGET = (MIN_TOL != null && MAX_TOL != null)
            ? (MIN_TOL + MAX_TOL) / 2
            : (allSamples.length ? mean(allSamples) : null);

        // sigmaWithin por subgrupos; si no se puede, cae a std poblacional
        let sigmaW = sigmaWithinFromSamples(samplesByTime);
        if (!sigmaW) sigmaW = allSamples.length ? stdPop(allSamples) : null;

        // Límites de control Y (ctrlY)
        let ctrlY = null;
        if (CTRL_MODE === 'data' && sigmaW && allSamples.length) {
            const mu = mean(allSamples);
            ctrlY = { LCL: mu - 3 * sigmaW, CL: mu, UCL: mu + 3 * sigmaW };
        } else if (CTRL_MODE === 'cp' && TARGET != null && isFinite(MIN_TOL) && isFinite(MAX_TOL) && CP_TARGET > 0) {
            const sigmaStar = (MAX_TOL - MIN_TOL) / (6 * CP_TARGET);
            ctrlY = { LCL: TARGET - 3 * sigmaStar, CL: TARGET, UCL: TARGET + 3 * sigmaStar };
        }

        // ------- Series y ejes -------
        const series = [];
        const yAxis = [];

        // Eje de Y (izquierda)
        yAxis.push({
            type: 'value',
            name: VAR_Y_NAME,
            position: 'left',
            min: minY,
            max: maxY,
            axisLine: { lineStyle: { color: '#00AA00' } },
            nameLocation: 'middle',
            nameRotate: 90,
            nameGap: 45,
            axisPointer: { label: { show: true } }
        });

        // Serie Y (promedio) con LSL/Target/UCL/LCL y áreas
        series.push({
            name: nombrePromedio,
            type: 'line',
            data: meanSeriesData,
            showSymbol: true,
            symbolSize: 6,
            smooth: false,
            markLine: {
                silent: true,
                symbol: 'none',
                lineStyle: { type: 'dashed' },
                label: { formatter: p => `${p.name} = ${(+p.value).toFixed(2)}` },
                data: [
                    { yAxis: MIN_TOL, name: T.Bell_LSL },
                    { yAxis: MAX_TOL, name: T.Bell_USL },
                    ...(TARGET != null ? [{ yAxis: TARGET, name: 'Target' }] : []),
                    ...(ctrlY ? [{ yAxis: ctrlY.LCL, name: 'LCL' }, { yAxis: ctrlY.UCL, name: 'UCL' }] : [])
                ]
            },
            markArea: {
                silent: true,
                data: [
                    [{ yAxis: minY }, { yAxis: MIN_TOL }],
                    [{ yAxis: MAX_TOL }, { yAxis: maxY }],
                    ...(ctrlY ? [[{ yAxis: ctrlY.LCL }, { yAxis: ctrlY.UCL }]] : [])
                ],
                itemStyle: {
                    color: params => (params.dataIndexInside <= 1)
                        ? 'rgba(220,20,60,.06)'   // OOS
                        : 'rgba(56,189,248,.10)'  // banda de control
                }
            }
        });

        // Serie Y (muestras) — scatter
        const muestrasSeriesData = [];
        Object.keys(samplesByTime).forEach(t => {
            (samplesByTime[t] || []).forEach(v => { muestrasSeriesData.push([t, v]); });
        });
        series.push({
            name: nombreMuestras,
            type: 'scatter',
            data: muestrasSeriesData,
            yAxisIndex: 0,
            symbolSize: 7,
            itemStyle: {
                color: p => {
                    const v = Array.isArray(p.value) ? p.value[1] : p.value;
                    return (v < MIN_TOL || v > MAX_TOL) ? '#d62728' : undefined;
                }
            }
        });

        // Variables X
        const xKeys = Object.keys(scatterDataX || {}).filter(k => k !== VAR_Y_NAME);
        const xMeans = Object.fromEntries(xKeys.map(k => [k, mean((scatterDataX[k] || []).filter(v => v != null))]));

        xKeys.forEach((key, index) => {
            if (!scatterDataX[key] || !scatterDataX[key].length) return;

            const filtered = scatterDataX[key].filter(v => v != null);
            const minX = filtered.length ? Math.min(...filtered) - 1 : 0;
            const maxX = filtered.length ? Math.max(...filtered) + 1 : 1;

            // Serie scatter de X (en su propio eje)
            series.push({
                name: key,
                type: 'scatter',
                data: scatterDataX[key].map((val, i) => [dates[i], val ?? null]),
                yAxisIndex: index + 1,
                symbolSize: 8
            });

            // UCL/LCL por X (opcional, con std poblacional)
            const xVals = filtered;
            if (xVals.length >= 3) {
                const muX = mean(xVals);
                const sdX = stdPop(xVals);
                const ctrlX = (CTRL_MODE === 'data' && sdX > 0)
                    ? { LCL: muX - 3 * sdX, CL: muX, UCL: muX + 3 * sdX }
                    : null;

                series.push({
                    name: `${key} UCL/LCL`,
                    type: 'line',
                    yAxisIndex: index + 1,
                    symbol: 'none',
                    data: dates.map(d => [d, null]), // serie "soporte" para markLine/markArea
                    markLine: ctrlX ? {
                        symbol: 'none',
                        lineStyle: { type: 'dotted' },
                        label: { formatter: p => `${p.name} = ${(+p.value).toFixed(2)}` },
                        data: [{ yAxis: ctrlX.LCL, name: 'LCL' }, { yAxis: ctrlX.UCL, name: 'UCL' }]
                    } : undefined,
                    markArea: ctrlX ? {
                        itemStyle: { color: 'rgba(56,189,248,.10)' },
                        data: [[{ yAxis: ctrlX.LCL }, { yAxis: ctrlX.UCL }]]
                    } : undefined
                });
            }

            // Eje para X
            yAxis.push({
                type: 'value',
                name: key,
                position: index % 2 === 0 ? 'right' : 'left',
                offset: index * 50,
                min: minX,
                max: maxX,
                axisLine: { lineStyle: { color: ['#FFA500', '#4169E1', '#8A2BE2'][index % 3] } },
                nameLocation: 'middle',
                nameRotate: 90,
                nameGap: 45,
                axisPointer: { label: { show: false } }
            });
        });

        // Leyenda: promedio Y, muestras Y, cada X y (opcional) bandas de X
        const legendItems = [
            nombrePromedio,
            nombreMuestras,
            ...xKeys,
            ...xKeys.map(k => `${k} UCL/LCL`)
        ];

        // Tooltip
        function tooltipFormatter(params) {
            const xLabel = params[0]?.axisValue || params[0]?.axisValueLabel || '';
            const promItem = params.find(p => p.seriesName === nombrePromedio);
            const muestras = samplesByTime[xLabel] || [];

            let html = `<b>${xLabel}</b><br/>`;
            html += `${T.Spec}: <b>${VAR_Y_NAME}</b><br/>`;
            if (promItem && Array.isArray(promItem.value)) {
                html += `${T.Mean}: <b>${Number(promItem.value[1]).toFixed(2)}</b><br/>`;
            }
            html += `${T.MinLimit}: ${MIN_TOL}<br/>${T.MaxLimit}: ${MAX_TOL}`;
            if (TARGET != null) html += `<br/>Target: ${TARGET.toFixed(2)}`;
            if (ctrlY) html += `<br/>LCL: ${ctrlY.LCL.toFixed(2)} &nbsp; CL: ${ctrlY.CL.toFixed(2)} &nbsp; UCL: ${ctrlY.UCL.toFixed(2)}`;

            if (muestras.length) {
                html += `<hr style="margin:4px 0"/>`;
                html += `<b>${T.Samples.replace('{0}', muestras.length)}</b><br/>`;
                html += muestras.slice().sort((a, b) => a - b).join('<br/>');
            }

            const idx = dates.indexOf(xLabel);
            if (idx >= 0 && xKeys.length) {
                html += `<hr style="margin:4px 0"/><b>${T.XVARS}</b><br/>`;
                xKeys.forEach(k => {
                    const val = (scatterDataX[k] && scatterDataX[k][idx] != null) ? scatterDataX[k][idx] : null;
                    if (val == null) return;
                    const dv = val - xMeans[k];
                    const arrow = dv > 0 ? '↑' : (dv < 0 ? '↓' : '→');
                    html += `${k}: <b>${val}</b> (${arrow} ${dv.toFixed(2)})<br/>`;
                });
            }
            return html;
        }

        // Render
        chart.setOption({
            title: { text: '', left: 'center' },
            grid: { left: 60, right: 120, top: 40, bottom: 60 },
            tooltip: { trigger: 'axis', formatter: tooltipFormatter, axisPointer: { type: 'cross' } },
            legend: { data: legendItems },
            xAxis: { type: 'category', data: xCategories },
            yAxis: yAxis,
            dataZoom: [
                { type: 'slider', xAxisIndex: 0, start: 0, end: 100 },
                { type: 'inside', xAxisIndex: 0 }
            ],
            series: series
        });

        // -------- Bell curve (tu lógica actual) --------
        function updateBellCurveChart(variableName, dataValues) {
            document.getElementById("bell-curve-loader").style.display = "block";
            setTimeout(() => {
                if (dataValues.length > 0) {
                    const meanVal = mean(dataValues);
                    const stdDev = Math.sqrt(dataValues.map(x => Math.pow(x - meanVal, 2)).reduce((a, b) => a + b) / dataValues.length);
                    const cpk = Math.min((MAX_TOL - meanVal) / (3 * stdDev), (meanVal - MIN_TOL) / (3 * stdDev));
                    const ppk = cpk * 1.2; // simulación
                    const range = Math.max(...dataValues) - Math.min(...dataValues);

                    let bellCurveData = [], histogramData = {};
                    for (let i = meanVal - 3 * stdDev; i <= meanVal + 3 * stdDev; i += stdDev / 2) {
                        let yValue = Math.exp(-Math.pow(i - meanVal, 2) / (2 * Math.pow(stdDev, 2)));
                        bellCurveData.push([i, yValue]);
                    }
                    dataValues.forEach(val => { let bucket = Math.round(val * 10) / 10; histogramData[bucket] = (histogramData[bucket] || 0) + 1; });
                    let histogramSeries = Object.keys(histogramData).map(b => [parseFloat(b), histogramData[b]]);
                    let minX = Math.min(...bellCurveData.map(d => d[0]), MIN_TOL) - 0.1;
                    let maxX = Math.max(...bellCurveData.map(d => d[0]), MAX_TOL) + 0.1;

                    document.getElementById("cpkValue").innerText = (Math.random() * 10).toFixed(3);
                    document.getElementById("ppkValue").innerText = (Math.random() * 5).toFixed(3);
                    document.getElementById("meanValue").innerText = meanVal.toFixed(2);
                    document.getElementById("rangeValue").innerText = range.toFixed(2);

                    bellCurveChart.setOption({
                        title: { text: T.Bell_Title },
                        tooltip: { trigger: 'axis' },
                        xAxis: { type: 'value', name: T.Bell_XAxis, min: minX, max: maxX },
                        yAxis: { type: 'value', name: T.Bell_YAxis },
                        dataZoom: [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }],
                        series: [
                            { name: T.Bell_Distribution, type: 'line', data: bellCurveData },
                            { name: T.Bell_Histogram, type: 'bar', data: histogramSeries },
                            { name: T.Bell_LSL, type: 'line', data: [[MIN_TOL, 0], [MIN_TOL, Math.max(...histogramSeries.map(h => h[1]))]] },
                            { name: T.Bell_USL, type: 'line', data: [[MAX_TOL, 0], [MAX_TOL, Math.max(...histogramSeries.map(h => h[1]))]] }
                        ]
                    });
                }
                document.getElementById("bell-curve-loader").style.display = "none";
            }, 50);
        }

        chart.on('click', function (params) {
            if (params.seriesName === nombrePromedio || params.seriesName === nombreMuestras) {
                const ts = params.name || (Array.isArray(params.value) ? params.value[0] : null);
                const muestras = ts ? (samplesByTime[ts] || []) : [];
                if (muestras.length) updateBellCurveChart(VAR_Y_NAME, muestras.slice(0, 1000));
                return;
            }
            if (params.seriesType === 'scatter') {
                setTimeout(() => {
                    const selectedVariable = params.seriesName;
                    if (scatterDataX[selectedVariable]) {
                        const data = scatterDataX[selectedVariable].slice(0, 1000);
                        updateBellCurveChart(selectedVariable, data);
                    }
                }, 30);
            }
        });

        function zoomOut() { let z = bellCurveChart.getOption().dataZoom[0]; bellCurveChart.setOption({ dataZoom: [{ start: Math.max(z.start - 10, 0), end: Math.min(z.end + 10, 100) }] }); }
        function zoomIn() { let z = bellCurveChart.getOption().dataZoom[0]; bellCurveChart.setOption({ dataZoom: [{ start: Math.min(z.start + 10, 100), end: Math.max(z.end - 10, 0) }] }); }
        function resetZoom() { bellCurveChart.setOption({ dataZoom: [{ start: 0, end: 100 }] }); }
    </script>
}
