@using Newtonsoft.Json
@using System.Collections.Generic
@inject Microsoft.Extensions.Localization.IStringLocalizer Localizer

@{
    ViewData["Title"] = Localizer["Result_Title"]; // "Quality Chart with Alerts"
    var data = ViewBag.Data;
    var allCandlestickData = ViewBag.AllCandlestickData as Dictionary<string, List<double[]>>;
    var variableYName = ViewBag.VariableYName as string;
    var variablesXData = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var selectedXVariables = ViewBag.SelectedXVariables as List<string>;
}

@{
    double minThreshold = ViewBag.MinThreshold ?? 0;
    double maxThreshold = ViewBag.MaxThreshold ?? 100;
}

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>

<style>
    .container-flex {
        display: flex;
        flex-direction: row;
        gap: 20px;
        align-items: flex-start;
    }

    #data-table {
        border-collapse: collapse;
        width: 250px;
    }

        #data-table th, #data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        #data-table th {
            background-color: #2c82c9;
            color: white;
        }

    #chart-container {
        flex-grow: 1;
        height: 600px;
    }

    .container-campana {
        display: flex;
        flex-direction: row; /* 📌 Alinear en fila */
        justify-content: space-between;
        align-items: flex-start;
        margin-top: 20px;
    }


    .leyenda-campana {
        width: 250px;
        padding: 10px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        font-size: 14px;
    }

    #bell-curve-container {
        flex-grow: 1;
        height: 400px;
        position: relative; /* Necesario para posicionar el loader */
    }

    @@keyframes pulse {
    0% { opacity: 0.5; }
    50% { opacity: 1; }
    100% { opacity: 0.5; }
}

#bell-curve-loader {
    animation: pulse 1.5s infinite;
}

    #loaderOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.9);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .loaderContent {
        text-align: center;
    }

    .bubbles {
        width: 50px;
        height: 50px;
        margin: auto;
        position: relative;
    }

        .bubbles::before,
        .bubbles::after {
            content: "";
            position: absolute;
            border-radius: 50%;
            animation: bubble 1s infinite ease-in-out;
        }

        .bubbles::before {
            width: 20px;
            height: 20px;
            background-color: #e11d48;
            left: 0;
        }

        .bubbles::after {
            width: 20px;
            height: 20px;
            background-color: #0284c7;
            right: 0;
            animation-delay: 0.5s;
        }

    @@keyframes bubble {
        0%, 100% {
            transform: translateY(0);
            opacity: 0.7;
        }

        50% {
            transform: translateY(-15px);
            opacity: 1;
        }
    }

    .loaderText {
        margin-top: 10px;
        font-size: 1rem;
        color: #333;
        font-weight: 500;
    }
</style>
<div class="container-flex">
    <div id="loaderOverlay">
        <div class="loaderContent">
            <div class="bubbles"></div>
            <p class="loaderText">@Localizer["Loader_Analyzing"]</p>
        </div>
    </div>

    <div id="chart-container"></div>
</div>

<div class="container-campana" style="display:flex; align-items:center; gap:10px;">
    <div id="bell-curve-container" style="width:75%; height:350px;"></div>

    <div class="leyenda-campana" style="width:15%; padding:8px; border:1px solid #ccc; border-radius:5px; font-size:12px; text-align:left;">
        <h4 style="margin:0 0 5px 0; font-size:14px;">@Localizer["Stats_Title"]</h4>
        <p><b>@Localizer["Stats_Cpk"]:</b> <span id="cpkValue">-</span></p>
        <p><b>@Localizer["Stats_Ppk"]:</b> <span id="ppkValue">-</span></p>
        <p><b>@Localizer["Stats_Mean"]:</b> <span id="meanValue">-</span></p>
        <p><b>@Localizer["Stats_Range"]:</b> <span id="rangeValue">-</span></p>

        <div style="margin-top:5px; display:flex; justify-content:center; gap:5px;">
            <button onclick="zoomOut()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_Out_Title"]">🔍➖</button>
            <button onclick="zoomIn()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_In_Title"]">🔍➕</button>
            <button onclick="resetZoom()" style="border:none; background:none; cursor:pointer; font-size:14px;" title="@Localizer["Zoom_Reset_Title"]">🔄</button>
        </div>
    </div>

    <div id="bell-curve-loader" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:10; background:rgba(255,255,255,.9); padding:20px; border-radius:12px; box-shadow:0 0 12px rgba(0,0,0,.15); text-align:center;">
        <svg width="50" height="50" viewBox="0 0 50 50">
            <circle cx="25" cy="25" r="20" fill="none" stroke="#3498db" stroke-width="5" stroke-linecap="round" stroke-dasharray="90" stroke-dashoffset="0">
                <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" from="0 25 25" to="360 25 25" />
            </circle>
        </svg>
        <div style="margin-top:10px; font-size:14px; color:#333;">@Localizer["Bell_Loading"]</div>
    </div>
</div>

<script>
    function toggleTable() { const c = document.getElementById('dataTableContainer'); c.style.display = c.style.display === "none" ? "block" : "none"; }
</script>

<button onclick="toggleTable()" style="margin-top:10px; padding:5px 10px;">📊 @Localizer["Button_ShowTable"]</button>

<div id="dataTableContainer" style="display:none; margin-top:15px;">
    <table id="dataTable" border="1" style="width:100%; text-align:center; border-collapse:collapse;">
        <thead>
            <tr>
                <th>@Localizer["Table_DateTime"]</th>
                <th>@ViewBag.VariableYName</th>
                @foreach (var xVar in ViewBag.VariablesXData.Keys)
                {
                    <th>@xVar</th>
                }
            </tr>
        </thead>
        <tbody>
            @for (int i = 0; i < ViewBag.Dates.Count; i++)
            {
                <tr>
                    <td>@ViewBag.Dates[i]</td>
                    <td>@(ViewBag.ScatterDataY.Count > i ? ((dynamic)ViewBag.ScatterDataY[i]).Value : "-")</td>
                    @foreach (var xVar in ViewBag.VariablesXData.Keys)
                    {
                        <td>@(ViewBag.VariablesXData[xVar].Count > i ? ViewBag.VariablesXData[xVar][i] : "-")</td>
                    }
                </tr>
            }
        </tbody>
    </table>
</div>

@{
    var datesJson = JsonConvert.SerializeObject(ViewBag.Dates ?? new List<string>());
    var scatterDataYJson = JsonConvert.SerializeObject(ViewBag.ScatterDataY ?? new List<object>());
    var variablesX = ViewBag.VariablesXData as Dictionary<string, List<double>> ?? new Dictionary<string, List<double>>();
    var scatterDataXJson = JsonConvert.SerializeObject(variablesX);
    var minTol = minThreshold;
    var maxTol = maxThreshold;
}

@section Scripts {
    <script>
        // Diccionario de textos para JS
        window.T = {
            Spec: '@Localizer["Tooltip_Spec"]',                    // "Spec"
            Mean: '@Localizer["Tooltip_Mean"]',                    // "Mean"
            MinLimit: '@Localizer["Tooltip_MinLimit"]',            // "Lower Spec Limit"
            MaxLimit: '@Localizer["Tooltip_MaxLimit"]',            // "Upper Spec Limit"
            Samples: '@Localizer["Tooltip_Samples"]',              // "Samples ({0})"
            XVARS: '@Localizer["Tooltip_XVars"]',                  // "X Variables"
            Bell_Title: '@Localizer["Bell_Title"]',                // "Normal Distribution - Variable"
            Bell_XAxis: '@Localizer["Bell_XAxis"]',                // "Variable"
            Bell_YAxis: '@Localizer["Bell_YAxis"]',                // "Frequency"
            Bell_Distribution: '@Localizer["Bell_Distribution"]',  // "Distribution"
            Bell_Histogram: '@Localizer["Bell_Histogram"]',        // "Histogram"
            Bell_LSL: '@Localizer["Bell_LSL"]',                    // "LSL"
            Bell_USL: '@Localizer["Bell_USL"]'                     // "USL"
        };

        var chart = echarts.init(document.getElementById('chart-container'));
        var bellCurveChart = echarts.init(document.getElementById('bell-curve-container'));

        window.addEventListener("load", function () { const loader = document.getElementById("loaderOverlay"); if (loader) loader.style.display = "none"; });

        const dates = @Html.Raw(datesJson);
        const scatterDataY = @Html.Raw(scatterDataYJson);
        const scatterDataX = @Html.Raw(scatterDataXJson);

        const VAR_Y_NAME = @Html.Raw(JsonConvert.SerializeObject(ViewBag.VariableYName ?? ""));
        const nombrePromedio = `${T.Mean} (${VAR_Y_NAME})`;
        const nombreMuestras = `Samples (${VAR_Y_NAME})`;

        const MIN_TOL = @minTol;
        const MAX_TOL = @maxTol;

        const samplesByTime = {};
        (scatterDataY || []).forEach(entry => {
            const t = entry?.Time;
            const v = Number(entry?.Value);
            if (!t || isNaN(v)) return;
            if (!samplesByTime[t]) samplesByTime[t] = [];
            samplesByTime[t].push(v);
        });

        const xSet = new Set(Object.keys(samplesByTime));
        Object.keys(scatterDataX || {}).forEach(key => {
            const arr = scatterDataX[key] || [];
            arr.forEach((_, i) => { const d = dates[i]; if (d != null) xSet.add(d); });
        });
        const xCategories = Array.from(xSet).sort((a, b) => new Date(a) - new Date(b));

        const mean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
        const meanSeriesData = Object.keys(samplesByTime).sort((a, b) => new Date(a) - new Date(b)).map(t => [t, mean(samplesByTime[t])]);

        const allSamples = Object.values(samplesByTime).flat();
        const minY = (allSamples.length ? Math.min(...allSamples, MIN_TOL) : MIN_TOL) - 1;
        const maxY = (allSamples.length ? Math.max(...allSamples, MAX_TOL) : MAX_TOL) + 1;

        let series = [], yAxis = [];
        yAxis.push({
            type: 'value', name: VAR_Y_NAME, position: 'left', min: minY, max: maxY,
            axisLine: { lineStyle: { color: '#00AA00' } }, nameLocation: 'middle', nameRotate: 90, nameGap: 45,
            axisPointer: { label: { show: true } }
        });

        series.push({
            name: nombrePromedio, type: 'line', data: meanSeriesData, showSymbol: true, symbolSize: 6, smooth: false,
            markLine: { silent: true, symbol: 'none', lineStyle: { type: 'dashed' }, data: [{ yAxis: MIN_TOL, name: T.Bell_LSL }, { yAxis: MAX_TOL, name: T.Bell_USL }] },
            markArea: { silent: true, itemStyle: { color: 'rgba(220,20,60,.06)' }, data: [[{ yAxis: -Infinity }, { yAxis: MIN_TOL }], [{ yAxis: MAX_TOL }, { yAxis: Infinity }]] }
        });

        const muestrasSeriesData = [];
        Object.keys(samplesByTime).forEach(t => { (samplesByTime[t] || []).forEach(v => { muestrasSeriesData.push([t, v]); }); });
        series.push({
            name: nombreMuestras, type: 'scatter', data: muestrasSeriesData, yAxisIndex: 0, symbolSize: 7,
            itemStyle: { color: p => { const v = Array.isArray(p.value) ? p.value[1] : p.value; return (v < MIN_TOL || v > MAX_TOL) ? '#d62728' : undefined; } }
        });

        const xKeys = Object.keys(scatterDataX || {}).filter(k => k !== VAR_Y_NAME);
        const xMeans = Object.fromEntries(xKeys.map(k => [k, mean((scatterDataX[k] || []).filter(v => v != null))]));

        xKeys.forEach((key, index) => {
            if (scatterDataX[key] && scatterDataX[key].length > 0) {
                const filtered = scatterDataX[key].filter(v => v != null);
                let minX = filtered.length ? Math.min(...filtered) - 1 : 0;
                let maxX = filtered.length ? Math.max(...filtered) + 1 : 1;

                series.push({ name: key, type: 'scatter', data: scatterDataX[key].map((val, i) => [dates[i], val ?? 0]), yAxisIndex: index + 1, symbolSize: 8 });
                yAxis.push({
                    type: 'value', name: key, position: index % 2 === 0 ? 'right' : 'left', offset: index * 50, min: minX, max: maxX,
                    axisLine: { lineStyle: { color: ['#FFA500', '#4169E1', '#8A2BE2'][index % 3] } }, nameLocation: 'middle', nameRotate: 90, nameGap: 45,
                    axisPointer: { label: { show: false } }
                });
            }
        });

        let dataZoom = [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }];

        function tooltipFormatter(params) {
            const xLabel = params[0]?.axisValue || params[0]?.axisValueLabel || '';
            const promItem = params.find(p => p.seriesName === nombrePromedio);
            const muestras = samplesByTime[xLabel] || [];

            let html = `<b>${xLabel}</b><br/>`;
            html += `${T.Spec}: <b>${VAR_Y_NAME}</b><br/>`;
            if (promItem) html += `${T.Mean}: <b>${Number(promItem.value[1]).toFixed(2)}</b><br/>`;
            html += `${T.MinLimit}: ${MIN_TOL}<br/>${T.MaxLimit}: ${MAX_TOL}`;

            if (muestras.length) {
                html += `<hr style="margin:4px 0"/>`;
                html += `<b>${T.Samples.replace('{0}', muestras.length)}</b><br/>`;
                html += muestras.slice().sort((a, b) => a - b).join('<br/>');
            }

            const idx = dates.indexOf(xLabel);
            if (idx >= 0 && xKeys.length) {
                html += `<hr style="margin:4px 0"/><b>${T.XVARS}</b><br/>`;
                xKeys.forEach(k => {
                    const val = (scatterDataX[k] && scatterDataX[k][idx] != null) ? scatterDataX[k][idx] : null;
                    if (val == null) return;
                    const dv = val - xMeans[k];
                    const arrow = dv > 0 ? '↑' : (dv < 0 ? '↓' : '→');
                    html += `${k}: <b>${val}</b> (${arrow} ${dv.toFixed(2)})<br/>`;
                });
            }
            return html;
        }

        chart.setOption({
            title: { text: '', left: 'center' },
            grid: { left: 60, right: 120, top: 40, bottom: 60 },
            tooltip: { trigger: 'axis', formatter: tooltipFormatter, axisPointer: { type: 'cross' } },
            legend: { data: [nombrePromedio, nombreMuestras, ...xKeys] },
            xAxis: { type: 'category', data: xCategories },
            yAxis: yAxis,
            dataZoom: dataZoom,
            series: series
        });

        function updateBellCurveChart(variableName, dataValues) {
            document.getElementById("bell-curve-loader").style.display = "block";
            setTimeout(() => {
                if (dataValues.length > 0) {
                    const meanVal = mean(dataValues);
                    const stdDev = Math.sqrt(dataValues.map(x => Math.pow(x - meanVal, 2)).reduce((a, b) => a + b) / dataValues.length);
                    const cpk = Math.min((MAX_TOL - meanVal) / (3 * stdDev), (meanVal - MIN_TOL) / (3 * stdDev));
                    const ppk = cpk * 1.2; // simulación
                    const range = Math.max(...dataValues) - Math.min(...dataValues);

                    let bellCurveData = [], histogramData = {};
                    for (let i = meanVal - 3 * stdDev; i <= meanVal + 3 * stdDev; i += stdDev / 2) {
                        let yValue = Math.exp(-Math.pow(i - meanVal, 2) / (2 * Math.pow(stdDev, 2)));
                        bellCurveData.push([i, yValue]);
                    }
                    dataValues.forEach(val => { let bucket = Math.round(val * 10) / 10; histogramData[bucket] = (histogramData[bucket] || 0) + 1; });
                    let histogramSeries = Object.keys(histogramData).map(b => [parseFloat(b), histogramData[b]]);
                    let minX = Math.min(...bellCurveData.map(d => d[0]), MIN_TOL) - 0.1;
                    let maxX = Math.max(...bellCurveData.map(d => d[0]), MAX_TOL) + 0.1;

                    document.getElementById("cpkValue").innerText = (Math.random() * 10).toFixed(3);
                    document.getElementById("ppkValue").innerText = (Math.random() * 5).toFixed(3);
                    document.getElementById("meanValue").innerText = meanVal.toFixed(2);
                    document.getElementById("rangeValue").innerText = range.toFixed(2);

                    bellCurveChart.setOption({
                        title: { text: T.Bell_Title },
                        tooltip: { trigger: 'axis' },
                        xAxis: { type: 'value', name: T.Bell_XAxis, min: minX, max: maxX },
                        yAxis: { type: 'value', name: T.Bell_YAxis },
                        dataZoom: [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }],
                        series: [
                            { name: T.Bell_Distribution, type: 'line', data: bellCurveData },
                            { name: T.Bell_Histogram, type: 'bar', data: histogramSeries },
                            { name: T.Bell_LSL, type: 'line', data: [[MIN_TOL, 0], [MIN_TOL, Math.max(...histogramSeries.map(h => h[1]))]] },
                            { name: T.Bell_USL, type: 'line', data: [[MAX_TOL, 0], [MAX_TOL, Math.max(...histogramSeries.map(h => h[1]))]] }
                        ]
                    });
                }
                document.getElementById("bell-curve-loader").style.display = "none";
            }, 50);
        }

        chart.on('click', function (params) {
            if (params.seriesName === nombrePromedio || params.seriesName === nombreMuestras) {
                const ts = params.name || (Array.isArray(params.value) ? params.value[0] : null);
                const muestras = ts ? (samplesByTime[ts] || []) : [];
                if (muestras.length) updateBellCurveChart(VAR_Y_NAME, muestras.slice(0, 1000));
                return;
            }
            if (params.seriesType === 'scatter') {
                setTimeout(() => {
                    const selectedVariable = params.seriesName;
                    if (scatterDataX[selectedVariable]) {
                        const data = scatterDataX[selectedVariable].slice(0, 1000);
                        updateBellCurveChart(selectedVariable, data);
                    }
                }, 30);
            }
        });

        function zoomOut() { let z = bellCurveChart.getOption().dataZoom[0]; bellCurveChart.setOption({ dataZoom: [{ start: Math.max(z.start - 10, 0), end: Math.min(z.end + 10, 100) }] }); }
        function zoomIn() { let z = bellCurveChart.getOption().dataZoom[0]; bellCurveChart.setOption({ dataZoom: [{ start: Math.min(z.start + 10, 100), end: Math.max(z.end - 10, 0) }] }); }
        function resetZoom() { bellCurveChart.setOption({ dataZoom: [{ start: 0, end: 100 }] }); }
    </script>
}