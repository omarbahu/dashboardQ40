@using Newtonsoft.Json
@{
    ViewData["Title"] = "Reporte Detallado";
    var scatterDataY = ViewBag.ScatterDataY as List<object>;
    var scatterDataX = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var variableYName = ViewBag.VariableYName as string;
    var variableY = ViewBag.VariableY as string;
    var variablesXData = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var selectedXVariables = ViewBag.SelectedXVariables as List<string>;
}
@{
    double minThreshold = ViewBag.MinThreshold ?? 0;  // Si es null, usa 0 por defecto
    double maxThreshold = ViewBag.MaxThreshold ?? 100; // Si es null, usa 100 por defecto
}
<style>
    /* 📌 Ajustar el contenedor principal para aprovechar toda la pantalla */
     /* 📌 Contenedor principal */
    .container-reporte {
        width: 98%;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    /* 📌 Grid en dos columnas */
    .reporte-detallado {
        display: grid;
        grid-template-columns: 1fr 1fr; /* 🔥 Dos columnas iguales */
        gap: 20px; /* Más espacio entre columnas */
        align-items: center;
    }

    /* 📌 Cada gráfico ocupa una columna completa */
    .grafico-container {
        display: flex;
        flex-direction: row; /* 🔥 Scatter y Campana lado a lado */
        align-items: center;
        gap: 20px;
    }

    /* 📌 Gráficas */
    .scatter-chart, .bell-curve-chart {
        flex: 1; /* 🔥 Que ocupen el mismo ancho */
        height: 400px; /* Ajuste de altura */
    }

    /* 📌 Media Query para pantallas pequeñas */
    @@media (max-width: 1024px) {
        .reporte-detallado {
            grid-template-columns: 1fr; /* 📌 Mostrar en una sola columna */
        }
    }

    @@media print {
        .print-full-width {
            width: 100% !important;
            page-break-inside: avoid;
        }

        .row {
            display: block !important; /* Asegura que no haya flex en impresión */
        }

        .scatter-chart, .bell-curve-chart {
            width: 100% !important;
            height: auto !important;
        }
    }
</style>
<div class="container-reporte">
    <h2>📊 Reporte Detallado</h2>

    <div class="container">
        <div class="row">
            <!-- 📌 Gráfico Principal de Variable Y -->
            <div class="col-md-6 col-12 print-full-width">
                <div class="scatter-chart" id="scatter-Y"></div>
            </div>
            <div class="col-md-6 col-12 print-full-width">
                <div class="bell-curve-chart" id="bell-Y"></div>
            </div>
        </div>

        <!-- 📌 Variables X -->
        @foreach (var xVar in scatterDataX.Keys)
        {
            <div class="row">
                <div class="col-md-6 col-12 print-full-width">
                    <div class="scatter-chart" id="scatter-@xVar.Replace(" ", "")"></div>
                </div>
                <div class="col-md-6 col-12 print-full-width">
                    <div class="bell-curve-chart" id="bell-@xVar.Replace(" ", "")"></div>
                </div>
            </div>
        }
    </div>
    
</div>

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>


<!-- 📌 Agregar Bootstrap JS si no está cargado -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>


<script>
    // 📌 Variables globales para los gráficos
    const scatterCharts = {};  // 📊 Contendrá las instancias de los gráficos Scatter
    const bellCurveCharts = {};  // 📊 Contendrá las instancias de las gráficas de Campana de Gauss

    // 📌 Obtener datos desde el servidor
    const dates = @Html.Raw(JsonConvert.SerializeObject(ViewBag.Dates ?? new List<string>()));
    const scatterDataY = @Html.Raw(JsonConvert.SerializeObject(ViewBag.ScatterDataY ?? new List<object>()));
    const scatterDataX = @Html.Raw(JsonConvert.SerializeObject(ViewBag.VariablesXData ?? new Dictionary<string, List<double>>()));

    const minThreshold = @Html.Raw(JsonConvert.SerializeObject(ViewBag.MinThreshold));
    const maxThreshold = @Html.Raw(JsonConvert.SerializeObject(ViewBag.MaxThreshold));

    console.log("📊 Fechas:", dates);
    console.log("📊 Datos de Variable Y:", scatterDataY);
    console.log("📊 Datos de Variables X:", scatterDataX);

    function createScatterChart(chartId, variableName, dataValues, minThreshold, maxThreshold) {
        let chart = echarts.init(document.getElementById(chartId));

        let series = [
            {
                name: variableName,
                type: 'scatter',
                data: dataValues.map(entry => [entry.Time, entry.Value]),
                symbolSize: 8,
                itemStyle: { color: '#00FF00' }
            },
            {
                name: 'Límite Mínimo',
                type: 'line',
                data: dates.map(date => [date, minThreshold]),
                lineStyle: { type: 'dashed', color: 'red' },
                symbol: 'none'
            },
            {
                name: 'Límite Máximo',
                type: 'line',
                data: dates.map(date => [date, maxThreshold]),
                lineStyle: { type: 'dashed', color: 'red' },
                symbol: 'none'
            }
        ];

        let yAxis = {
            type: 'value',
            name: variableName,
            min: Math.min(...dataValues.map(entry => entry.Value), minThreshold) - 1,
            max: Math.max(...dataValues.map(entry => entry.Value), maxThreshold) + 1,
            axisLine: { lineStyle: { color: '#00FF00' } }
        };

        chart.setOption({
            title: { text: variableName },
            tooltip: { trigger: 'axis' },
            legend: { data: [variableName, 'Límite Mínimo', 'Límite Máximo'] },
            xAxis: { type: 'category', data: dates },
            yAxis: yAxis,
            dataZoom: [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }],
            series: series
        });

        scatterCharts[variableName] = chart;

        // 📌 Hacer clic en un punto para actualizar la campana de Gauss
        chart.on('click', function (params) {
            if (params.seriesType === 'scatter') {
                updateBellCurveChart(variableName, dataValues.map(entry => entry.Value));
            }
        });
    }

    function createBellCurveChart(chartId, variableName, dataValues) {
        console.log(variableName)
        let chart = echarts.init(document.getElementById(chartId));

        if (dataValues.length === 0) return;

        // 📌 Calcular estadísticos
        const mean = dataValues.reduce((a, b) => a + b, 0) / dataValues.length;
        const stdDev = Math.sqrt(dataValues.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / dataValues.length);
        const cpk = Math.min((@ViewBag.MaxThreshold - mean) / (3 * stdDev), (mean - @ViewBag.MinThreshold) / (3 * stdDev));
        const ppk = cpk * 1.2;
        const range = Math.max(...dataValues) - Math.min(...dataValues);

     

        // 📌 Generar la curva de distribución normal
        let bellCurveData = [];
        for (let i = mean - 3 * stdDev; i <= mean + 3 * stdDev; i += stdDev / 10) {
            let yValue = Math.exp(-Math.pow(i - mean, 2) / (2 * Math.pow(stdDev, 2)));
            bellCurveData.push([i, yValue]);
        }

        // 📌 Generar histograma
        let histogramData = {};
        dataValues.forEach(val => {
            let bucket = Math.round(val * 10) / 10;
            histogramData[bucket] = (histogramData[bucket] || 0) + 1;
        });

        let histogramSeries = Object.keys(histogramData).map(bucket => [parseFloat(bucket), histogramData[bucket]]);

        let minX = Math.min(...bellCurveData.map(d => d[0]), @ViewBag.MinThreshold) - 0.1;
        let maxX = Math.max(...bellCurveData.map(d => d[0]), @ViewBag.MaxThreshold) + 0.1;

        chart.setOption({
            title: { text: `Distribución - ${variableName}` },
            tooltip: { trigger: 'axis' },
            xAxis: { type: 'value', name: variableName, min: minX, max: maxX },
            yAxis: { type: 'value', name: 'Frecuencia' },
            dataZoom: [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }],
            series: [
                { name: 'Distribución', type: 'line', data: bellCurveData, lineStyle: { color: '#FF4500' } },
                { name: 'Histograma', type: 'bar', data: histogramSeries, itemStyle: { color: '#4682B4' } },
                {
                    name: 'LEI',
                    type: 'line',
                    data: [[@ViewBag.MinThreshold, 0], [@ViewBag.MinThreshold, Math.max(...histogramSeries.map(h => h[1]))]],
                    lineStyle: { color: 'red', type: 'solid' }
                },
                {
                    name: 'LES',
                    type: 'line',
                    data: [[@ViewBag.MaxThreshold, 0], [@ViewBag.MaxThreshold, Math.max(...histogramSeries.map(h => h[1]))]],
                    lineStyle: { color: 'red', type: 'solid' }
                }
            ]
        });

        bellCurveCharts[variableName] = chart;

        updateTooltip(variableName, cpk, ppk, mean, range);
        /*
        // 📌 Actualizar la leyenda
        document.getElementById(`cpk-${variableName}`).innerText = cpk.toFixed(3);
        document.getElementById(`ppk-${variableName}`).innerText = ppk.toFixed(3);
        document.getElementById(`mean-${variableName}`).innerText = mean.toFixed(2);
        document.getElementById(`range-${variableName}`).innerText = range.toFixed(2);
        */
    }

    // 📌 Inicializar todas las gráficas
    createScatterChart("scatter-Y", "@ViewBag.VariableYName", scatterDataY, @ViewBag.MinThreshold, @ViewBag.MaxThreshold);
    createBellCurveChart("bell-Y", "@ViewBag.VariableYName", scatterDataY.map(entry => entry.Value));

    Object.keys(scatterDataX).forEach((xVar) => {
        createScatterChart(`scatter-${xVar.replace(/\s/g, '')}`, xVar, scatterDataX[xVar].map((val, i) => ({ Time: dates[i], Value: val })), @ViewBag.MinThreshold, @ViewBag.MaxThreshold);
        createBellCurveChart(`bell-${xVar.replace(/\s/g, '')}`, xVar, scatterDataX[xVar]);
    });

    // 📌 Habilitar tooltips en Bootstrap
 
    document.addEventListener("DOMContentLoaded", function () {
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.forEach(function (tooltipTriggerEl) {
            new bootstrap.Tooltip(tooltipTriggerEl, { html: true, placement: "right" });
        });
    });
    // 📌 Función para actualizar las estadísticas en el tooltip
    function updateTooltip(variableName, cpk, ppk, mean, range) {
        let tooltipElement = document.querySelector(`[data-bs-toggle="tooltip"][data-variable="${variableName}"]`);

        if (tooltipElement) {
            let newTitle = `
                📊 <b>CPK:</b> ${cpk.toFixed(3)} <br>
                📊 <b>PPK:</b> ${ppk.toFixed(3)} <br>
                📊 <b>Promedio:</b> ${mean.toFixed(2)} <br>
                📊 <b>Rango:</b> ${range.toFixed(2)}
            `;

            // 📌 Actualizar el tooltip manualmente
            tooltipElement.setAttribute("data-bs-original-title", newTitle);

            // 📌 Eliminar cualquier instancia previa del tooltip
            let tooltipInstance = bootstrap.Tooltip.getInstance(tooltipElement);
            if (tooltipInstance) {
                tooltipInstance.dispose();
            }

            // 📌 Crear una nueva instancia del tooltip con los valores actualizados
            new bootstrap.Tooltip(tooltipElement, { html: true, placement: "right" });
        }
    }


</script>

