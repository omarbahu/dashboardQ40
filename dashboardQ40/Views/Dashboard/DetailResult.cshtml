@using Newtonsoft.Json
@inject Microsoft.Extensions.Localization.IStringLocalizer Localizer

@{
    ViewData["Title"] = Localizer["DetailResult_Title"]; // "Detailed Report"
    var scatterDataY = ViewBag.ScatterDataY as List<object>;
    var scatterDataX = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var variableYName = ViewBag.VariableYName as string;
    var variableY = ViewBag.VariableY as string;
    var variablesXData = ViewBag.VariablesXData as Dictionary<string, List<double>>;
    var selectedXVariables = ViewBag.SelectedXVariables as List<string>;

    // >>> nuevo
    var variableXNames = ViewBag.VariableXNames as Dictionary<string, string>;
}

@{
    double minThreshold = ViewBag.MinThreshold ?? 0;
    double maxThreshold = ViewBag.MaxThreshold ?? 100;
}

<style>
    /* 📌 Ajustar el contenedor principal para aprovechar toda la pantalla */
     /* 📌 Contenedor principal */
    .container-reporte {
        width: 98%;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    /* 📌 Grid en dos columnas */
    .reporte-detallado {
        display: grid;
        grid-template-columns: 1fr 1fr; /* 🔥 Dos columnas iguales */
        gap: 20px; /* Más espacio entre columnas */
        align-items: center;
    }

    /* 📌 Cada gráfico ocupa una columna completa */
    .grafico-container {
        display: flex;
        flex-direction: row; /* 🔥 Scatter y Campana lado a lado */
        align-items: center;
        gap: 20px;
    }

    /* 📌 Gráficas */
    .scatter-chart, .bell-curve-chart {
        flex: 1; /* 🔥 Que ocupen el mismo ancho */
        height: 400px; /* Ajuste de altura */
    }

    /* 📌 Media Query para pantallas pequeñas */
    @@media (max-width: 1024px) {
        .reporte-detallado {
            grid-template-columns: 1fr; /* 📌 Mostrar en una sola columna */
        }
    }

    @@media print {
        .print-full-width {
            width: 100% !important;
            page-break-inside: avoid;
        }

        .row {
            display: block !important; /* Asegura que no haya flex en impresión */
        }

        .scatter-chart, .bell-curve-chart {
            width: 100% !important;
            height: auto !important;
        }
    }

#loaderOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
}

.loaderContent {
    text-align: center;
}

.bubbles {
    width: 50px;
    height: 50px;
    margin: auto;
    position: relative;
}

.bubbles::before,
.bubbles::after {
    content: "";
    position: absolute;
    border-radius: 50%;
    animation: bubble 1s infinite ease-in-out;
}

.bubbles::before {
    width: 20px;
    height: 20px;
    background-color: #e11d48;
    left: 0;
}

.bubbles::after {
    width: 20px;
    height: 20px;
    background-color: #0284c7;
    right: 0;
    animation-delay: 0.5s;
}

@@keyframes bubble {
    0%, 100% {
        transform: translateY(0);
        opacity: 0.7;
    }
    50% {
        transform: translateY(-15px);
        opacity: 1;
    }
}

.loaderText {
    margin-top: 10px;
    font-size: 1rem;
    color: #333;
    font-weight: 500;
}

</style>
<div class="container-reporte">

    <div id="loaderOverlay">
        <div class="loaderContent">
            <div class="bubbles"></div>
            <p class="loaderText">@Localizer["Loader_Analyzing"]</p>
        </div>
    </div>

    <h2>📊 @Localizer["DetailReport_Header"]</h2>

    <div class="container">
        <div class="row">
            <!-- 📌 Gráfico Principal de Variable Y -->
            <div class="col-md-6 col-12 print-full-width">
                <div class="scatter-chart" id="scatter-Y"></div>
            </div>
            <div class="col-md-6 col-12 print-full-width">
                <div class="bell-curve-chart" id="bell-Y"></div>
            </div>
        </div>

        <!-- 📌 Variables X -->
        @foreach (var xVar in scatterDataX.Keys)
        {
            var displayName = (variableXNames != null && variableXNames.ContainsKey(xVar))
            ? variableXNames[xVar]
            : xVar;

            <div class="row">
                <div class="col-md-6 col-12 print-full-width">
                    <div class="scatter-chart"
                         id="scatter-@xVar.Replace(" ", "")"
                         data-xcode="@xVar"
                         data-xname="@displayName"></div>
                </div>
                <div class="col-md-6 col-12 print-full-width">
                    <div class="bell-curve-chart"
                         id="bell-@xVar.Replace(" ", "")"
                         data-xcode="@xVar"
                         data-xname="@displayName"></div>
                </div>
            </div>
        }

    </div>
    
</div>

<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>


<!-- 📌 Agregar Bootstrap JS si no está cargado -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

@section Scripts {
    <script>
        // ===== Diccionario para JS =====
        window.T = {
            MinLimit: '@Localizer["MinLimit"]',
            MaxLimit: '@Localizer["MaxLimit"]',
            Dist_TitleFmt: '@Localizer["Dist_TitleFmt"]',
            Dist_YAxis: '@Localizer["Dist_YAxis"]',
            Dist_Line: '@Localizer["Dist_Line"]',
            Dist_Hist: '@Localizer["Dist_Hist"]',
            Dist_LSL: '@Localizer["Dist_LSL"]',
            Dist_USL: '@Localizer["Dist_USL"]',
            Legend_Min: '@Localizer["Legend_Min"]',
            Legend_Max: '@Localizer["Legend_Max"]',
            Stats_Cpk: '@Localizer["Stats_Cpk"]',
            Stats_Ppk: '@Localizer["Stats_Ppk"]',
            Stats_Mean: '@Localizer["Stats_Mean"]',
            Stats_Range: '@Localizer["Stats_Range"]'
        };

        // ✅ SOLO ESTE BLOQUE, sin las const duplicadas de arriba
        const dates = @Html.Raw(JsonConvert.SerializeObject(ViewBag.Dates ?? new List<string>()));
        const scatterDataY = @Html.Raw(JsonConvert.SerializeObject(ViewBag.ScatterDataY ?? new List<object>()));
        const scatterDataX = @Html.Raw(JsonConvert.SerializeObject(ViewBag.VariablesXData ?? new Dictionary<string, List<double>>()));
        const variableXNames = @Html.Raw(JsonConvert.SerializeObject(ViewBag.VariableXNames ?? new Dictionary<string, string>()));

        const minThreshold = @Html.Raw(JsonConvert.SerializeObject(ViewBag.MinThreshold));
        const maxThreshold = @Html.Raw(JsonConvert.SerializeObject(ViewBag.MaxThreshold));

        window.addEventListener("load", function () { const loader = document.getElementById("loaderOverlay"); if (loader) loader.style.display = "none"; });

        const scatterCharts = {};
        const bellCurveCharts = {};

        function createScatterChart(chartId, variableName, dataValues, minThreshold, maxThreshold) {
            let chart = echarts.init(document.getElementById(chartId));

            let series = [
                {
                    name: variableName,
                    type: 'scatter',
                    data: dataValues.map(entry => [entry.Time, entry.Value]),
                    symbolSize: 8
                },
                {
                    name: T.Legend_Min,
                    type: 'line',
                    data: dates.map(date => [date, minThreshold]),
                    lineStyle: { type: 'dashed' },
                    symbol: 'none'
                },
                {
                    name: T.Legend_Max,
                    type: 'line',
                    data: dates.map(date => [date, maxThreshold]),
                    lineStyle: { type: 'dashed' },
                    symbol: 'none'
                }
            ];

            let yAxis = {
                type: 'value',
                name: variableName,
                min: Math.min(...dataValues.map(entry => entry.Value), minThreshold) - 1,
                max: Math.max(...dataValues.map(entry => entry.Value), maxThreshold) + 1
            };

            chart.setOption({
                title: { text: variableName },
                tooltip: { trigger: 'axis' },
                legend: { data: [variableName, T.Legend_Min, T.Legend_Max] },
                xAxis: { type: 'category', data: dates },
                yAxis: yAxis,
                dataZoom: [{ type: 'slider', xAxisIndex: 0, start: 0, end: 100 }, { type: 'inside', xAxisIndex: 0 }],
                series: series
            });

            scatterCharts[variableName] = chart;

            chart.on('click', function (params) {
                if (params.seriesType === 'scatter') {
                    updateBellCurveChart(variableName, dataValues.map(entry => entry.Value));
                }
            });
        }

        function createBellCurveChart(chartId, variableName, dataValues) {
            const dom = document.getElementById(chartId);
            if (!dom || !dataValues || !dataValues.length) return;

            const chart = echarts.init(dom);

            // Estadísticos básicos
            const mean = dataValues.reduce((a, b) => a + b, 0) / dataValues.length;
            const variance = dataValues.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / dataValues.length;
            const stdDev = Math.sqrt(variance);
            const range = Math.max(...dataValues) - Math.min(...dataValues);

            // Histograma
            const histogramData = {};
            dataValues.forEach(val => {
                const bucket = Math.round(val * 10) / 10;
                histogramData[bucket] = (histogramData[bucket] || 0) + 1;
            });
            const histogramSeries = Object.keys(histogramData).map(b => [parseFloat(b), histogramData[b]]);
            const maxHist = histogramSeries.length ? Math.max(...histogramSeries.map(h => h[1])) : 0;

            const minSpec = @ViewBag.MinThreshold;
            const maxSpec = @ViewBag.MaxThreshold;

            const minX = Math.min(...dataValues, minSpec) - 0.1;
            const maxX = Math.max(...dataValues, maxSpec) + 0.1;

            const titleText = T.Dist_TitleFmt.replace('{0}', variableName);

            const series = [];

            // 🔹 Histograma siempre
            series.push({
                name: T.Dist_Hist,
                type: 'bar',
                data: histogramSeries
            });

            // 🔹 Líneas LSL / USL
            if (isFinite(minSpec)) {
                series.push({
                    name: T.Dist_LSL,
                    type: 'line',
                    data: [[minSpec, 0], [minSpec, maxHist]],
                    symbol: 'none',
                    lineStyle: { type: 'dashed' }
                });
            }
            if (isFinite(maxSpec)) {
                series.push({
                    name: T.Dist_USL,
                    type: 'line',
                    data: [[maxSpec, 0], [maxSpec, maxHist]],
                    symbol: 'none',
                    lineStyle: { type: 'dashed' }
                });
            }

            // 🔹 Solo dibujamos campana si stdDev es válido y > 0
            let cpk = null;
            let ppk = null;

            if (isFinite(stdDev) && stdDev > 0) {
                const bellCurveData = [];
                const from = mean - 3 * stdDev;
                const to = mean + 3 * stdDev;
                const step = (to - from) / 60; // 60 puntos aprox

                for (let x = from; x <= to; x += step) {
                    const y = Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
                    bellCurveData.push([x, y]);
                }

                series.unshift({
                    name: T.Dist_Line,
                    type: 'line',
                    data: bellCurveData,
                    smooth: true,
                    symbol: 'none'
                });

                cpk = Math.min(
                    (maxSpec - mean) / (3 * stdDev),
                    (mean - minSpec) / (3 * stdDev)
                );
                ppk = cpk * 1.2;
            }

            chart.setOption({
                title: { text: titleText },
                tooltip: { trigger: 'axis' },
                xAxis: { type: 'value', name: variableName, min: minX, max: maxX },
                yAxis: { type: 'value', name: T.Dist_YAxis },
                dataZoom: [
                    { type: 'slider', xAxisIndex: 0, start: 0, end: 100 },
                    { type: 'inside', xAxisIndex: 0 }
                ],
                series: series
            });

            bellCurveCharts[variableName] = chart;
            updateTooltip(variableName, cpk, ppk, mean, range);
        }


        // Inicialización
        // Y
        createScatterChart("scatter-Y", "@ViewBag.VariableYName", scatterDataY, minThreshold, maxThreshold);
        createBellCurveChart("bell-Y", "@ViewBag.VariableYName", scatterDataY.map(entry => entry.Value));

        // X
        Object.keys(scatterDataX || {}).forEach((xVar) => {
            const displayName = (variableXNames && variableXNames[xVar]) ? variableXNames[xVar] : xVar;
            const domId = xVar.replace(/\s/g, '');

            // Scatter de X
            createScatterChart(
                `scatter-${domId}`,
                displayName,
                scatterDataX[xVar].map((val, i) => ({ Time: dates[i], Value: val })),
                minThreshold,
                maxThreshold
            );

            // Campana de X
            createBellCurveChart(
                `bell-${domId}`,
                displayName,
                scatterDataX[xVar]
            );
        });



        // Tooltips Bootstrap (si usas)
        document.addEventListener("DOMContentLoaded", function () {
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(function (el) { new bootstrap.Tooltip(el, { html: true, placement: "right" }); });
        });

        function updateTooltip(variableName, cpk, ppk, mean, range) {
            let el = document.querySelector(`[data-bs-toggle="tooltip"][data-variable="${variableName}"]`);
            if (!el) return;

            const cpkText = (cpk == null || !isFinite(cpk)) ? "—" : cpk.toFixed(3);
            const ppkText = (ppk == null || !isFinite(ppk)) ? "—" : ppk.toFixed(3);
            const meanText = (mean == null || !isFinite(mean)) ? "—" : mean.toFixed(2);
            const rangeText = (range == null || !isFinite(range)) ? "—" : range.toFixed(2);

            let html = `
                📊 <b>${T.Stats_Cpk}:</b> ${cpkText} <br>
                📊 <b>${T.Stats_Ppk}:</b> ${ppkText} <br>
                📊 <b>${T.Stats_Mean}:</b> ${meanText} <br>
                📊 <b>${T.Stats_Range}:</b> ${rangeText}
            `;

            el.setAttribute("data-bs-original-title", html);
            let inst = bootstrap.Tooltip.getInstance(el);
            if (inst) inst.dispose();
            new bootstrap.Tooltip(el, { html: true, placement: "right" });
        }

    </script>
}